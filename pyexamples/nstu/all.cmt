bbb
{
nispmx = 31	# maximum number of ion species
ngspmx = 6	# maximum number of gas species; also must set in com.v
nmcmx = 12	# maximum number of EIRENE test species in data file 'fort.44'
ndomainmx = 128	# maximum number of domains for domain decomposition
nxptmx = 2      # maximum number of x-points in R-Z domain
ndcsmx = nispmx*nxptmx	# data dimension for csfaclb and csfacrb
}

***** Dim_vars hidden:
# Dimension variables for automatically written routines bbbdata & bbbwake.
# These variables need never be set, because those routines don't access array
# elements.
nx	integer		# number of cells in x (poloidal) direc. (see also nxm)
ny	integer		# number of cells in y (radial) direction
nxm	integer		# total number of cells in x direc.; nxm = nx+|nxomit|
nym	integer		# total number of cells in y direc.; nym = ny+nyomitmx
nxpt    integer         # number of x-points in (R,Z) simulation domain
nzsp(1:ngspmx) integer 	# number of impurity species per gas species
nzspt   integer         # total number of impurity species
nzspmx  integer		# maximum of nzsp(igsp) used for storage allocation
nisp	integer		# number of ion species
nusp	integer		# number of species with momentum equations
nfsp	integer		# number of continuity eqns or flux species
ngsp	integer		# number of gas species
nhgsp   integer         # number of hydrogen gas species (prepare for tritium)
imx	integer		# x dimension for Zagorski arrays
imy	integer		# y dimension for Zagorski arrays
lnst	integer		# dimension for impurity arrays for Zagorski output 

***** Math_problem_size:
neqmx		integer		# number of math. eqns to be solved/integrated
numvar		integer		# number of physical variables per cell

***** UEpar:
#  Parameters and switches for the simulation
csfaclb(nispmx,nxptmx)  real /ndcsmx*1./  #frac of cs used for Bohm sheath b.c.
csfacrb(nispmx,nxptmx)  real /ndcsmx*1./  #frac of cs used for Bohm sheath b.c.
csfacti   real            /1./  #Bohm speed = sqrt((te+csfacti*ti)/mi)
cslim     real            /1./  #frac of cs used for limiter Bohm sheath b.c.
dcslim    real            /0./  #reduce sonic flow at limiter by the factor
                                #cslim*[1-exp(-(iy-iy_lims+1)/dcslim)]
lnlam     real            /12./ #Coulomb log;shouldn't be constant
methe     integer         /33/  #elec. eng. eqn: 22-cd, 33-uw, 44-hyb, 55-p-law
methu     integer         /33/  #ion mom. eqn: 22-cd, 33-uw, 44-hyb, 55-p-law
methn     integer         /33/  #ion cont. eqn: 22-harmonic average, 33-uw
methi     integer         /33/  #ion eng. eqn: 22-cd, 33-uw, 44-hyb, 55-p-law
methg     integer         /33/  #neut. gas eqn: 22-cd, 33-uw, 44-hyb, 55-p-law
                                #66 nonorth. log intrp, 77 nonorth. 1/ng intrp
methp     integer         /33/  #potential eqn: 22-cd, 33-uw, 44-hyb, 55-p-law
isgxvon   integer         /0/   #=0 uses gx in fmix, =1 uses harmonic ave. of gxf
isvylog   real            /0/   #=0 for vy~(1/n)dn/dy; =1 for vy~d(log(n))/dy
isintlog  integer         /0/   #nonog logrithm interp for remaining terms
concap    integer         /0/   #=1 fixes Te and Ti to afix for thermal cond.
convis    integer         /0/   #=1 fixes Te to afix for ion viscosity
cniatol   real            /1./  #multiplier for atol for ni
cngatol   real            /1./  #multiplier for atol for ng
cupatol   real            /1./  #multiplier for atol for up
cteatol   real            /1./  #multiplier for atol for te
ctiatol   real            /1./  #multiplier for atol for ti
cphiatol  real            /1./  #multiplier for atol for phi
tolbf     real            /1./  #multiplier for atol&rtol for the boundary eqns
tadj      real            /10./ #reduces time step by 1/tadj if iopts=1
icnuiz    integer         /0/   #=1 constant ioniz. freq., cnuiz; =2 freezes
icnucx    integer         /0/   #=0, var nucx;=1 const. nucx=cnucx; 
                                # =2, use sigcx, so nucx~(Tg)**.5
cnuiz     real [1/s]      /5.e+4/ #constant ioniz. freq. for icnuiz=1
cnucx     real [1/s]      /1.e+0/ #constant charge exhange freq. for icnucx=1
isrecmon  integer         /0/  +restart 
				 #flag to turn-on recombination (yes=1); use
				 #cfrecom to turn-off recomb after isrecmon was on
cfrecom   real            /1./ +restart
                                  #scale factor multiplying recombination freq.
igas      integer         /0/     #=1 invokes local rate eqn. for ng
ngbackg(ngspmx) real [1/m**3] /ngspmx*1.e14/ + restart
                                  #background gas density
ingb      integer         /2/     #background gas source=nuiz*ngbackg*
                                  #                  (.9+.1*(ngbackg/ng)**ingb)
nzbackg   real [1/m**3]   /1.e9/ + restart
                                  #background impurity density
inzb      integer         /2/     #background impurity source=nuiz*nzbackg*
                                  #                 (.9+.1*(nzbackg/nzi)**ingb)
nlimix(nispmx) real  /nispmx*0./  #factor to prevent ion density pump out in x
nlimiy(nispmx) real  /nispmx*0./  #factor to prevent ion density pump out in y
nlimgx	  real            /0./    #factor to prevent ion density pump out in x
nlimgy	  real            /0./    #factor to prevent ion density pump out in y
is1D_gbx  integer         /0/     #=1 turns on 1-D gas-box model
xgbx      real [m]        /.25/   #poloidal location of 1-D gas box
ixgb      integer         /0/     #poloidal index of xgbx 1-D gas box (calc)
agdc      real            /1./    #exp. decay factor ng from gas-box edge
pcolwid   real [m]        /0./    #width of plasma column for 1-D gas-box model
eion      real [eV]       /5./    #energy that ionized ion is born with
ediss     real [eV]       /10./ +restart
                                  #elec eng lost by mol. dissoc; should = 2*eion
ebind     real [eV]     /13.6/ +restart
                                  #binding energy carried by hydrogen ion
tfcx      real [eV]       /10./ +restart
                                  #Franck-Condon temp. in poloidal(x) direct.
tfcy      real [eV]       /10./ +restart
                                  #Franck-Condon temp. in radial (y) direction
afix      real [e]        /50./   #Te,i for fixed cond.(concap), visc.(convis)
coef      real            /0.96/  #factor for ion viscosity: was 1.92 ???
ce        real            /3.16/  #factor for electron thermal conductivity
ci        real            /3.9/   #factor for ion thermal conductivity
                #The zeff dependence of ce has been explicitly added in zcoef,
                #thus ce should always be left as 3.16 even if zeff is not 1,
                #provided zeff is less than or equal to 4.
ncrhs     integer
istep     integer
iter      integer
dp1       real
qfl       real
csh       real
qsh       real
mfl       real
msh       real
ro        real
cs        real
fxe       real
ctaue     real
fxi       real
ctaui     real
zcoef     real          #factor (calc) give zeff dependence of elec thermal c.
coef1     real          #factor (calc) for energy equipartion rate
cnurn     real    /1./  #scales nurlx rate for ion continuity eqn.
cnuru     real    /1./  #scales nurlx rate for ion mom. eqn.
cnure     real    /1./  #scales nurlx rate for elec. eng. eqn.
cnuri     real    /1./  #scales nurlx rate for ion eng. eqn.
cnurg     real    /1./  #scales nurlx rate for gas eqn.
cnurp     real    /1./  #scales nurlx rate for potential eqn.
nurlxn    real
nurlxu    real
nurlxe    real
nurlxi    real
nurlxg    real
nurlxp    real
label     character*72 #code name and run time, date, and machine
rnewpot   real    /0./ #mixture of fqy=(1-rnewpot)*fqy_old+rnewpot*fqy_new
r0slab	  real [m]/1e-20/ #effect. major radius for isnewpot j_r calc in slab
ishymol   integer  /0/ #=1 turns on hydr. mol; requires nhgsp=2
te_s_dis  real     /5./ #Te shift of ioniz curve to approx dissociation curve
isfqpave  integer  /0/ #=0 for lin interp for fqp terms; =1 for simple ave.
svrpkg    character*8 /"vodpk"/ #use solver pkg daspk,vodpk,nksol,newton
                                #reset to newton if inewton=1
isgpye    integer  /0/ #change -vy*dP/dy eng. terms; =1 for old B2; =2 for Knoll
iigsp     integer      # Ion index for neutrals when isupgon=1 (zi(iigsp)=0)
fnnuiz    real    /1./ #fraction of new nuiz used for Jacobian
itrap_negni integer /1/ #flag to trap negative ni condition
itrap_negt integer /1/ #flag to trap negative Te,i condition
itrap_negng integer /1/ #flag to trap negative ng condition
isybdryog integer  /0/ #=1 sets fx0, fmx stencil to orthog values at iy=0 & ny
isybdrywd integer  /0/ #=1 vy diffusion-only for iy=0 & ny if matwalli,o=1
isxmpog   integer  /0/ #=1 sets fy0, fmy stencil to orthog values at ix=nxc-1
                       # and ix=nxc+1 for geometry='dnbot'
ineudif   integer  /1/ #=1 gas sub. neudif uses ng, tg for gas vel & fngx->fnix
		       #=2 gas sub. neudifgp uses pg for gas vel & fngx->fnix
		       #=3 gas sub. neudifl use log_ng, tg for gas vel
		       #otherwise, old case has ug=ui (strong cx coupling)
thetar    real    /0./ #rotate (R,Z) coordinates by angle theta (degrees)
isbcwdt   integer /0/  #include dtreal in B.C. if isbcwdt=1
ishosor   integer /0/  #if=1, integrate hydr. sources over cell; full RHS only
fsprd     real /.0625 / #fraction of eng. sor. spread to each of 4 neighbors
issyvxpt0 integer /0/  #if=1, set syv=0 around x-point; ambig. rad. mom. flux
isrrvave  integer /0/  #if=0, rrv from vertex B's; if=1, rrv=0.5*(rr_1+rr_2); 
                       #if=2, average of cases 0 and 1
rr_fac    real    /1./ #scale factor to multiple rr and rrv
rrmin     real    /0./ #min rr used in calc of u_tor & fqy for potential calc.
isdtsfscal integer /0/ #if=1, dt is included in sfscal Jac scaling factor
frfqpn    real    /1./ #frac. of new fqp at ix=0,nx using grad at ix=1,nx-1
cffqpsat  real    /1./ #factor by which fqp can exceed fqpsatlb,rb (sat. cur)
isplflxl  integer /1/  #=0, flalfe,i not active at ix=0 & nx;=1 active all ix 
flalfipl  real /1.e20/ #ion therm flux lim factor on plates when isplflxl=0
flalfepl  real /1.e20/ #elec therm flux lim factor on plates when isplflxl=0
isfeexpl0 integer  /0/ #if=1, feex cannot be out of inner/outer plates
isofric   integer /0/  #If =1, use old (B2) interspecies up drag expression 
del_te_ro real /1e10/  #te width in eV of tanh which turns off pwrze below 1 eV
iskaboom  integer /0/  #=1 turns on ijmgetmr "k" or "kaboom" stopping option
isnglf	  integer /0/  #=1 gives ng=nglfix at ix=0
nglfix    real  /1e15/ #value of ng at ix=0 if isnglf=1
isngrf	  integer /0/  #=1 gives ng=nglfix at ix=nx+1
ngrfix    real  /1e19/ #value of ng at ix=nx+1 if isnglf=1
isnion(nispmx) integer  /nispmx*1/   #user:turns on (=1) ion continuity eqn.
isupon(nispmx) integer  /nispmx*1/   #user:turns on (=1) parallel vel. eqn.
isupgon(ngspmx) integer /ngspmx*0/   #user:=1 for par neutral vel. eqn.; index igsp
isteon      integer  /1/             #user:turns on (=1) electron energy eqn.
istion      integer  /1/             #user:turns on (=1) ion enegy eqn.
isngon(ngspmx) integer  /6*1/        #user:turns on (=1) neutral eqn.; index igsp
isphion     integer  /0/             #user:turns on (=1) potential eqn.
isphiofft integer  /0/ #user:=1 leaves old cur. on & ex=-d(phis)/dx; must be used
                       #with isphion=0
isnewpot  integer  /0/ #user:turns on (=1) new potential; J_r from tor. mom. bal.
                       #=-2 sets phi constant on core boundary with
                       #total core current = icoreelec 
isnionxy(0:nx+1,0:ny+1,nisp)  _integer   #calc:=1 for ni eqn on; =0 for eqn off
isuponxy(0:nx+1,0:ny+1,nisp)  _integer   #calc:=1 for up eqn on; =0 for eqn off
isteonxy(0:nx+1,0:ny+1)	      _integer   #calc:=1 for te eqn on; =0 for eqn off
istionxy(0:nx+1,0:ny+1)	      _integer   #calc:=1 for ti eqn on; =0 for eqn off
isngonxy(0:nx+1,0:ny+1,ngsp)  _integer   #calc:=1 for ng eqn on; =0 for eqn off
isphionxy(0:nx+1,0:ny+1)      _integer   #calc:=1 for phi eqn on; =0 for eqn off
isnioffxy(0:nx+1,0:ny+1,nisp) _integer   #user:=1 for ni eqn off; =0 for eqn on
isupoffxy(0:nx+1,0:ny+1,nisp) _integer   #user:=1 for up eqn off; =0 for eqn on
isteoffxy(0:nx+1,0:ny+1)      _integer   #user:=1 for te eqn off; =0 for eqn on
istioffxy(0:nx+1,0:ny+1)      _integer   #user:=1 for ti eqn off; =0 for eqn on
isngoffxy(0:nx+1,0:ny+1,ngsp) _integer   #user:=1 for ng eqn off; =0 for eqn on
isphioffxy(0:nx+1,0:ny+1)     _integer   #user:=1 for phi eqn off; =0 for eqn on
fdtnixy(0:nx+1,0:ny+1,nisp) _real   #user:=1 for ni eqn off; =0 for eqn on
fdtupxy(0:nx+1,0:ny+1,nisp) _real   #user:=1 for up eqn off; =0 for eqn on
fdttexy(0:nx+1,0:ny+1)      _real   #user:=1 for te eqn off; =0 for eqn on
fdttixy(0:nx+1,0:ny+1)      _real   #user:=1 for ti eqn off; =0 for eqn on
fdtngxy(0:nx+1,0:ny+1,ngsp) _real   #user:=1 for ng eqn off; =0 for eqn on
fdtphixy(0:nx+1,0:ny+1)     _real   #user:=1 for phi eqn off; =0 for eqn on

***** Model_choice restart:
#Flags for choosing one or another calculation of a part of the model
iondenseqn	character*8	/"llnl"/	# ion continuity equation

***** Coefeq restart:
#Coefficients for the different terms in the fluid equations.
cnfx      real      /1./    #X-flux coef for conv. in n-eq.
cnfy      real      /1./    #Y-flux coef for conv. in n-eq.
cnsor     real      /1./    #Coef for particle src. in n-eq.
cfneut    real      /1./    #Coef for fluid neutrals contrib's to resid's
cfnidh    real      /1./    #Coef for neutral-ion drift heating
cfupcx    real      /1./    #Coef for nucx*(up_ion - up_gas) momentum coupling
cfticx    real      /1./    #Coef for nucx*(up_ion-up_gas)**2 heating in Ti Eq
cfupimpg  real      /0./    #Coef for impur up Cx/elast drag on up=0 imp gas
cftiimpg  real      /0./    #Coef for Ti cooling CX/elast loss to cold imp gas
cmneut    real      /0./    #Coef for Monte Carlo neutrals contrib's to resid's
cnflux(ngspmx) real /ngspmx*1./ #coef for particle flux in n-eq. (resco)
chradi    real      /1./    #Coef for hyd. ioniz. rad. loss in elec. eng. eq.
chradr    real      /1./    #Coef for hyd. recomb. rad. loss in elec. eng. eq.
chioniz   real      /1./    #Coef for hydrogen ionization in elec. eng. eq.
ifxnsgi   integer   /0/	    #=1 sets ne for <sig*v>_i to cne_sgvi
cne_sgvi  real [1/m**3] /1.e18/ #ne for <sig*v>_i if ifxnsgi=1
ctsor     real      /1./    #Coef for eng. src. in Ti eq. 0.5*mi*up**2*psor
ceisor    real      /1./    #scale fac for ion energy source term (nu_i & eion)
ccoldsor  real      /0./    #scale fac for ion eng loss from cold cx
cngfx(ngspmx)  real /ngspmx*1./#scale fac for flux from grad_x T_g in gas eqn.
cngfy(ngspmx)  real /ngspmx*1./#scale fac for flux from grad_y T_g in gas eqn.
cngmom(nispmx) real /nispmx*0./#mom. cx-loss coeff for diffusve-neut hydr only
cmwall(nispmx) real /nispmx*0./#mom. wall-loss coeff for diff-neut hydr only
cngtgx(ngspmx) real /ngspmx*0./#X-flux coef for gas comp. of Ti eqn. 
cngtgy(ngspmx) real /ngspmx*0./#Y-flux coef for gas comp. of Ti eqn.
sxgsol    real      /1./    #stretches x-coord. for gas in sol & core regions
sxgpr     real      /1./    #stretches x-coord. for gas in private flux region
xstscal   real  [m] /1./    #scale-length with stretch-coord decays from plates
rld2dxg(ngspmx) real /ngspmx*0./ #ratio of gas decay-length to dx via artificial diff.
rld2dyg(ngspmx) real /ngspmx*0./ #ratio of gas decay-length to dy via artificial diff.
cngflox(ngspmx) real /ngspmx*1./ #fac for x-flux from convection in ng-eqn.
cngfloy(ngspmx) real /ngspmx*1./ #fac for y-flux from convection in ng-eqn.
cngsor          real    /1./     #Coef for part. src. in ng-eq.
cdifg(ngspmx)   real /ngspmx*1./ #scale factor for gas diffusion coeff.
lgmax(ngspmx)   real /ngspmx*1.e20/ #max gas scale length for calc particle D_g
lgtmax(ngspmx)  real /ngspmx*1.e20/ #max gas scale length for calc. thermal D_g
lgvmax          real   /1.e20/   #max gas scale length for calc. viscous D_g
rtg2ti(ngspmx)  real /ngspmx*1./ #ratio of gas temp to ion temp
tgas(ngspmx) real [eV] /ngspmx*1./ #value of tg if istgcon=1
cmfx      real      /1./    #X-flux coef for conv. in up-eq.
cmfy      real      /1./    #Y-flux coef for conv. in up-eq.
cpgx      real      /1./    #Coef for Grad(p) in up-eq.
cfvisx    real      /1./    #Coef. for x-visc. in ti-eq.
cfvisy    real      /1./    #Coef. for y-visc. in ti-eq.
cfvcsx(1:nispmx) real /nispmx*1./  #Coefs for x-visc. in ti-eq. with ismcnon>0
cfvcsy(1:nispmx) real /nispmx*1./  #Coefs for y-visc. in ti-eq. with ismcnon>0
vboost    real      /1./    #previously scaled eqp; no longer in use
cvgp      real      /1./    #Coef for v.Grad(p) terms.
cfvgpx(1:nispmx) real /nispmx*1./ #Coefs for x components of v.grad(p) in ti-eq
cfvgpy(1:nispmx) real /nispmx*1./ #Coefs for y components of v.grad(p) in ti-eq
cfbgt     real      /0./    #Coef for the B x Grad(T) terms.
cfjhf     real      /1./    #Coef for convective cur (fqp) heat flow
jhswitch  integer   /0/     #Coef for the Joule-heating terms
cf2ef     real      /0./    #Coef for ExB drift in 2-direction
cfyef     real      /0./    #Coef for ExB drift in y-direction
cftef     real      /0./    #Coef for ExB drift in toroidal direction
cf2bf     real      /0./    #Coef for Grad B drift in 2-direction
cfybf     real      /0./    #Coef for Grad B drift in y-direction
cfcbti    real      /0./    #Coef for adding fnixcb & fniycb to Ti eqn.
cfcurv	  real      /1./    #Coef for curvature part of Grad_B drift
cfgradb   real      /1./    #Coef for p_perp part of Grad_B drift	
cfq2bf    real      /0./    #Coef for Grad_B current in 2-direction
cfqybf    real      /0./    #Coef for Grad_B current in y-direction
cfqyn     real      /0./    #Coef for cx coll. rad current in y-direction
cfqym     real      /0./    #Coef for spatial inertial rad current in y-dir.
cfqydt    real      /0./    #Coef for time-dep inertial rad current in y-dir.
cf2dd     real      /0./    #Coef for diamagnetic drift in 2-direction
cfydd     real      /0./    #Coef for diamagnetic drift in y-direction
cftdd     real      /0./    #Coef for diamagnetic drift in toroidal direction
cfrd      real      /0./    #Coef for resistive cross-field drift
cfvycr    real      /0./    #Coef for thermal force class. vel. vycr
cfvycf    real      /0./    #Coef for visc. force class. vel. vycf
cfjve     real      /0./    #Coef for J-contribution to ve.
cfjp2     real      /0./    #Coef for B x gradP terms in div(J) eqn
cfjpy     real      /0./    #Coef for B x gradP terms in div(J) eqn
isnfmiy   integer   /0/     #switch for new fmiy for vel. cells touching x-pt.
cfnfmiy   real      /1./    #Coef for new fmiy for vel. cells touching x-pt.
cnimp	  real	    /1./    #Coef for impurity radiation loss
fac2sp    real  [ ] /1./    #factor to test 2-species model; for
                            #equal densities, set fac2sp=2
$$$cfw(1:10) real   /0.1,9*1./ #Coeff's for the parallel neutral momentum eq.
$$$                            #cfw(1)*(the local sound speed) is the parallel
$$$                            #neutral velocity out of the plate (bound. con.)
cftnm     real  [ ] /0./    #Coef for neutral cx in toroidal mom. eq for fqy
cfupjr    real  [ ] /0./    #coef to include u_par in Jr calc.
cfcximp1  real  [ ] /1./    #coef multi. kcxrz for imp(+1)+D(0)->imp(0)+D(+1) 
cfcximp2  real  [ ] /1./    #coef mult. kcxrz;imp(+p)+D(0)->imp(p-1)+D(+1),p>1
cfnetap   real  [ ] /1./    #coef mult. netap*fqp term in frice express.
fcdif     real  [ ] /1./    #coef mult all constant anomal diff coef
cfmsor    real  [ ] /1./    #coef mult msor and msorxr in up eqn.
cpiup(nispmx) real /nispmx*1./ #mult. press. grad term in up eqn
cfloyi    real  [ ] /2.5/   #coef mult ion radial convective energy flow
cfloye    real  [ ] /2.5/   #coef mult elec radial convective energy flow
cfcvte	  real  [ ] /1.0/   #coef mult elec poloidal convect(~5/2) energy flow
cfcvti	  real  [ ] /1.0/   #coef mult ion & neut pol convect(~5/2) energy flow
cfloxiplt real  [ ] /1.0/   #coef mult neutral convect engy from plates
exjbdry   real  [ ] /10./   #exponent pwr to limit fqp < fqpsat at plates
cfgpijr   real  [ ] /1./    #scalar factor for grad_Pi term in fqya
iszeffcon integer   /0/     #if =1, zeff=zeffcon
zeffcon   real      /1./    #value of zeff if iszeffcon=1
alftng    real      /0./    #neutral thermal force coeff; careful of sign

***** Bcond restart:
#Variables for setting the boundary conditions.
ibctepl   integer	/1/	#Switch for ix=0 energy flux bc's
				#=0, fixed te (see tepltl)
				#=1, standard sheath transmission b.c.
				#=2, zero poloidal gradients for te
ibctipl	  integer       /1/     # Same as ibctepl, with te --> ti
ibctepr   integer	/1/	#Switch for ix=nx+1 energy flux bc's
				#=0, fixed te (see tepltr)
				#=1, standard sheath transmission b.c.
				#=2, zero poloidal gradients for te
ibctipr   integer       /1/	# Same as ibctepr, with te --> ti
isphilbc	integer	/0/     #Switch for ix=0 b.c. on phi
				#=0, phi = phi0l + kappal * te
				#=1, phi = phi0l
isphirbc	integer	/0/     #Switch for ix=nx+1 b.c. on phi
				#=0, phi = phi0r + kappar * te
				#=1, phi = phi0r
iphibcc 	integer /0/	#core BC on iy=1 when isnewpot=1;
                                #=0, dphi(ix,1)=dphi_iy1(ix) and isutcore ctrls
                                #=1, d^2(ey)/dy^2=0
                                #=2, te=constant and isutcore ctrls constant
                                #=3, phi=constant and isutcore ctrls constant
iphibcwi        integer /0/     #=0, d(ey)/dy=0
				#=1, phi(ix,0) = phintewi*te(ix,0)/ev
				#=3, d(phi)/dy/phi = 1/lyphi(1)
iphibcwo        integer /0/     #=0, d(ey)/dy=0
				#=1, phi(ix,ny+1) = phintewi*te(ix,ny+1)/ev
				#=3, d(phi)/dy/phi = 1/lyphi(2)
phintewi        real /3./	#phi/te on inner wall if iphibcwi=1
phintewo        real /3./	#phi/te on outer wall if iphibcwo=1
ncore(nispmx)  real [m**-3]/nispmx*7.e19/ #core ion dens if isnicore=1
upcore(nispmx) real [m/s]  /nispmx*0./    #core ion parall vel. if isupcore=0
ngcore(ngspmx) real [m**-3]/ngspmx*1.e15/ #core gas dens if isngcore=1
isnicore(nispmx)  integer   /1,30*0/      #switch for ion-density core B.C.
				    #=1, set uniform, fixed density, ncore
				    #=0, set flux to curcore/sy locally in ix
				    #=2, set flux & ni over range
				    #=3, set icur=curcore-recycc*fngy, const ni
				    #=4, use impur. source terms (impur only)
				    #=5, set d(ni)/dy=-ni/lynicore
isupcore(nispmx) integer /nispmx*0/ #=0 sets up=upcore on core bdry
				    #=1 sets d(up)/dy=0 on the core bdry
				    #=2 sets d^2(up)/dy^2 = 0
 				    #=3 sets poloidal velocity (uu) = 0
			   	    #=4 sets tor. ang mom flux = lzcore & up/R=const
isngcore(ngspmx) integer /ngspmx*0/ #switch for neutral-density core B.C.
				    #=0, set loc flux= -(1-albedoc)*ng*vtg/4
				    #=1, set uniform, fixed density, ngcore
				    #=2, set rad. grad. to sqrt(lam_i*lam_cx)
				    #=3, extrapolation, but limited
				    #=anything else, set zero deriv which was
				    #prev default inert hy
				    # anything else same as =0
curcore(1:nispmx) real [A] /0.,30*0./ #value of current from core if isnicore=0
lzcore(1:nispmx)  real [kg/ms] /nispmx*0./ #tor. ang. mom density on core bndry
icoreelec real [A]   /0./    # electrical current from core
cfniybbo  real       /0./    # factor to includ. vycb in fniy,feiy at iy=0 only
cfniydbo  real       /0./    # factor to includ. vycp in fniy,feiy at iy=0 only
cfeeybbo  real       /0./    # factor to includ. vycb in feey at iy=0 only
cfeeydbo  real       /0./    # factor to includ. vycp in feey at iy=0 only
cfeexdbo  real       /0./    # factor includ v2cde & BxgradTe in BC at ix=0,nx
cfeixdbo  real       /0./    # factor includ v2cdi & BxgradTi in BC at ix=0,nx 
cfqybbo   real       /0./    # factor to includ. fqyb in core current B.C. only
cfqydbo   real       /0./    # factor to includ. fqyd in core current B.C. only
nfqya0core integer   /0/     # num iy core cells beyond iy=0 where force fqya=0
nfqya0pf  integer    /1/     # num. iy pf cells beyond iy=0 where force fqya=0
nfqya0ow  integer    /1/     # num iy outer wall cell below iy=ny+1 with fqya=0
ixfixnc   integer    /1/     # ix where ni=ncore if isnicore=2 begins
incixc	  integer    /0/     # ix range for ni=ncore from ixfixnc if isnicore=2
tcoree    real [eV] /50./    #core elecron temp if iflcore=0
tcorei    real [eV] /50./    #core ion temp if iflcore=0
tedge     real [eV] /2./     #edge ion and elec. temp; used for te,iwalli,o
                             #arrays if last element zero (as in interpolation)
tepltl    real [eV]  /2./    #left plate Te B.C. if iflux=0
tipltl    real [eV]  /2./    #left plate Ti B.C. if iflux=0
tepltr    real [eV]  /2./    #right plate Te B.C. if iflux=0
tipltr    real [eV]  /2./    #right plate Ti B.C. if iflux=0
tbmin     real [eV] /.1/     #min. wall & pf temp for extrap. b.c.(isextrt..)
nbmin     real [m**-3] /1.e17/ #min. wall & pf den for extrap. b.c.(isextrn..)
ngbmin    real [m**-3] /1.e10/ #min. core gas den for extrap. b.c.(isextrngc)
istewc    integer    /1/     # switch for outer-wall BC on Te
			     # =0, set zero energy flux
	 		     # =1, set fixed temp to tedge or tewallo
			     # =2, use extrapolation BC
			     # =3, set Te scale length to lyte
                             # =4, set feey = bceew*fniy*te
istiwc    integer    /1/     #switch for outer-wall BC on Ti, see istewc detail
istepfc   integer    /0/     # switch for priv.-flux BC on Te
			     # =0, set zero energy flux
	 		     # =1, set fixed temp to tedge or tewalli
			     # =2, use extrapolation BC
			     # =3, set Te scale length to lyte
                             # =4, set feey = bceew*fniy*te
istipfc   integer    /0/     #switch for priv.-flux BC on Ti, see istewc detail
tewalli(0:nx+1) _real [eV] #/(nx+2)*0./ 
                             #inner wall Te for istepfc=1.; = tedge if not set
tiwalli(0:nx+1) _real [eV] #/(nx+2)*0./
                             #inner wall Ti for istipfc=1.; = tedge if not set
tewallo(0:nx+1) _real [eV] #/(nx+2)*0./
                             #outer wall Te for istewc=1.; = tedge if not set
tiwallo(0:nx+1) _real [eV] #/(nx+2)*0./
                             #outer wall Ti for istiwc=1.; = tedge if not set
lyte(1:2)  real /2*1e20/ [m] #decaying rad Te grad leng;(1,2) istepfc,wc=3
lyti(1:2)  real /2*1e20/ [m] #decaying rad Ti grad leng;(1,2) istipfc,wc=3
lyphi(1:2) real /2*1e20/ [m] #decaying rad phi grad leng;(1,2) iphibcwi,o=3
isextrnp  integer   /0/      #=1 sets extrap. b.c. at div. plate bound'y for ni
isextrnpf integer   /0/      #=1 sets extrap. b.c. at p.f. bound'y for ni
isextrtpf integer   /0/      #=1 sets extrap. b.c. at p.f. bound'y for Te & Ti
isextrngc integer   /0/      #=1 sets extrap. b.c. on core bdry for ng
isextrnw  integer   /0/      #=1 sets extrap. b.c. at outer wall for ni
isextrtw  integer   /0/      #=1 sets extrap. b.c. at outer wall for Te & Ti
iflcore   integer   /0/      #=0, core Te,i=tcoree,i; =1 core power=pcoree,i;
			     #=-1, core d(Te,i)/dy=0
pcoree    real [W]  /4e4/    #electron power from core if iflcore=1
pcorei    real [W]  /4e4/    #ion power from core if iflcore=1
ifluxni   integer  /1/       #flag for setting iy=0,ny+1 dens flux to 0 (=1,yes)
ckinfl    real    /1./       #includes kinetic viscosity in energy bound. cond.
isupss(nispmx) integer /nispmx*0/ +restart
                             #=0, up=cs; =1, up>=1; =-1, dup/dx=0 at plates
isbohmms  integer /0/        #=0 for single-species Bohm; =1 for multispecies B
isnwconi(1:nispmx) integer /nispmx*0/
		#switch for private-flux wall (iy=0) density B.C.
		#=0, old case; if ifluxni=0, dn/dy=0; if ifluxni=1, fniy=0 
		#=1, fixed density to nwallo(ix) array
		#=2, extrapolation B.C.
		#=3, approx grad-length lyni, but limited by nwimin
isnwcono(1:nispmx) integer /nispmx*0/
		#switch for outer wall (iy=ny+1) density B.C.
		#=0, old case; if ifluxni=0, dn/dy=0; if ifluxni=1, fniy=0 
		#=1, fixed density to nwallo(ix) array
		#=2, extrapolation B.C.
		#=3, approx grad-length lyni, but limited by nwomin
nwalli(0:nx+1) _real [m**-3] #inner wall dens set by isnwconi
nwallo(0:nx+1) _real [m**-3] #outer wall dens set by isnwcono
nwimin(nispmx)  real [m**-3] /nispmx*1e16/  # min inner wall dens if isnwconi=3
nwomin(nispmx)  real [m**-3] /nispmx*1e16/  # min outer wall dens if isnwcono=3
ncoremin(nispmx) real [m**-3] /nispmx*1e10/ # min ncore for isnicore=5
lyni(2)         real [m]     /2*1e20/       #rad dens grad length -isnwconi,o=3
isulynix        integer      /0/            #if=0, lynix filled with lyni 
					    #if=1, user values of lynix used
lynix(2,0:nx+1,nisp) _real [m] # pol dep radial dens grad length if set < 1e5
			         # isnwconi,o=3: 1:2=i:o, 2nd dim ix, 3rd spec
lynicore(nispmx) real [m] /nispmx*1e20/     # ni core BC rad scale-length if
					    # isnicore=5
lyup(2) real    /2*1e20/     #radial up grad length if isupwi,o=3: 1:2=i:o
nwsor     integer    /1/     #number of sources on wall; must be < 10
igasi(10) real [Amp] /10*0./ #Gas currents from inner wall (iy=0)
igaso(10) real [Amp] /10*0./ #Gas currents from outer wall (iy=ny+1)
igspsori(10) integer /10*1/  #index of gas species for inner wall sources
igspsoro(10) integer /10*1/  #index of gas species for outer wall sources
issorlb(10) integer  /10*1/  +restart
                             #flag for coord. origin of source.;=1, left plate;
                             #=0, right plate
jxsori(10)  integer  /10*1/  # xgasi=0. is located at left boundary
                             # of mesh region jxsori
jxsoro(10)  integer  /10*1/  # xgaso=0. is located at left boundary
                             # of mesh region jxsoro
xgasi(10) real [m]   /10*0./ +restart
                             #location of inner wall sources; if issorlb(i)=1,0 
                             #measured from left plate, right plate 
xgaso(10) real [m]   /10*0./ +restart
                             #location of outer wall sources; if issorlb(i)=1,0,
                             #measured from left plate, right plate
wgasi(10)  real [m] /10*100./ +restart
                             #total cosine widths of inner wall gas sources
wgaso(10)  real [m] /10*100./ +restart
                             #total cosine widths of outer wall gas sources
albdsi(10) real [m] /10*1.0/ #albedos at inner gas source locations
albdso(10) real [m] /10*1.0/ #albedos at outer gas source locations
chemsputi(10,10)   /100*0/   #chem sputt coeff, priv flux surface, flux(i)=
                             # sum(chemsputi(i,j)*ng(j)*vt*sy)
chemsputo(10,10)   /100*0/   #chem sputt coeff, outer wall - see chemsputi def.
matwsi(10) integer  /10*0/   #material wall at inner gas source locations
matwso(10) integer  /10*0/   #material wall at outer gas source locations
issori(10) integer  /10*0/   #starting ix cell index for inner source
iesori(10) integer  /10*0/   #ending ix cell index for inner source
issoro(10) integer  /10*0/   #starting ix cell index for outer source
iesoro(10) integer  /10*0/   #ending ix cell index for outer source
iwalli(10) real     /10*0./  #current from inner source region isor for coupling
iwallo(10) real     /10*0./  #current from outer source region isor for coupling
ncpli(10)  integer  /10*0/   #flag for coupling between inner srce isor & ncpli
ncplo(10)  integer  /10*0/   #flag for coupling between outer srce isor & ncpli
cplsori(10)  real   /10*0./  #coeff. giving coupling from inner isor to ncpli
cplsoro(10)  real   /10*0./  #coeff. giving coupling from outer isor to ncpli
iscpli(0:nx+1)      _integer #(=1) => ix pt involved in inner bndry coupling
iscplo(0:nx+1)      _integer #(=1) => ix pt involved in outer bndry coupling
fwsori(0:nx+1,10)    _real   #profile of inner wall source isor (missing igasi)
fwsoro(0:nx+1,10)    _real   #profile of outer wall source isor (missing igasi)
fngysi(0:nx+1,ngsp)  _real -restart
                             #gas input flux from igasi on inner wall (calc)
fngyso(0:nx+1,ngsp)  _real -restart
                             #gas input flux from igaso on outer wall (calc)
albedoo(0:nx+1,ngsp) _real -restart
                             #albedo of outer iy=ny+1 surface for neutrals (calc)
albedoi(0:nx+1,ngsp) _real -restart
                             #albedo of inner iy=0 surface for neutrals (calc)
matwallo(0:nx+1)     _integer -restart
                             #flag (=1) denoting outer material side wall
matwalli(0:nx+1)     _integer -restart
                             #flag (=1) denoting inner material side wall (pf)
sinphi    real         /.1/     #sine of angle between side wall and flux surf.
isfixlb   integer      /0/      #(=1) fixed values left bndry;=2 for symm. pt.
isfixrb   integer      /0/      #=2 for symmetry pt. at ix=nx+1
nib(20)   real [m**-3]/20*5.e19/#left plate density for isfixlb=1
upb(20)   real [m/s]  /20*1e2/  #left plate parallel velocity for isfixlb=1
teb       real [eV]    /50./    #left plate electron temp for isfixlb=1
tib       real [eV]    /50./    #left plate ion temp for isfixlb=1
ywnii     real [m]     /.01/    #inner Gaussian radial width of nib
ywnio     real [m]     /.04/    #outer Gaussian radial width of nib
ywupi     real [m]     /.01/    #inner Gaussian radial width of upb
ywupo     real [m]     /.04/    #outer Gaussian radial width of upb
ywtei     real [m]     /.01/    #inner Gaussian radial width of teb
ywteo     real [m]     /.04/    #outer Gaussian radial width of teb
ywtii     real [m]     /.01/    #inner Gaussian radial width of tib
ywtio     real [m]     /.04/    #outer Gaussian radial width of tib
nibprof(0:ny+1) _real -restart  #radial profile of nib
upbprof(0:ny+1) _real -restart  #radial profile of upb
tebprof(0:ny+1) _real -restart  #radial profile of teb
tibprof(0:ny+1) _real -restart  #radial profile of tib
engbsr    real [ ]     /1./     #energy factor for backscattered neutrals to Ti
epsbs     real [ ]     /1.e-5/  #small fac added (substracted) from Rbs (Rfc)
isguardc  integer      /1/      #using guard cells? (=1 yes, =0 no)
rlimiter  real [m]     /1.e20/  #position of limiter at ix=0 for isfixlb=2
islimsor  integer      /0/      #=1 extends sources into limiter region
isutcore  integer      /0/      #=0, tor mom=lzcore on core; =1, d<uz>/dy=0;
				#=2, d^2(Ey)/dy^2=0 at outer midplane
isiy1bc   integer      /0/      #=0 sets phi on iy=1 as if te were constant
                                #=1 sets te constant on iy=1
                                #=2 sets phi constant on iy=1
isupwi    integer      /1/      #=0 sets up=0 on inner wall
                                #=1 sets fmiy=0 (parallel mom-dens y-flux)
              			#=2 sets dup/dy=0 on inner wall
              			#=3 sets (1/up)dup/dy=1/lyup(1) scale length
isupwo    integer      /1/      #=0 sets up=0 on outer wall
                                #=1 sets fmiy=0 (parallel mom-dens y-flux)
              			#=2 sets dup/dy=0 on outer wall
              			#=3 sets (1/up)dup/dy=1/lyup(2) scale length
islbcn    integer      /2/	# b.c. for ni at limiter guard cells;
				# =0,1 set ni in 2 cells
				# =2 set ni in 1 cell, fnix at interface
islbcu    integer      /5/	# b.c. for up at limiter guard cells;
				# =0,1 set up in 3 cells
				# =2 set up in 2 cells, fmix at interface
				# =3,4,6 set fmix at interface
				# =5 set fmix-fmixy at interface
islbce    integer      /2/	# b.c. for te at limiter guard cells;
				# =0,1 set te in 2 cells
				# =2 set te in 1 cell, feex at interface
islbci    integer      /2/	# b.c. for ti at limiter guard cells;
				# =0,1 set ti in 2 cells
				# =2 set ti in 1 cell, feix at interface
islbcg    integer      /2/	# b.c. for ng at limiter guard cells;
				# =0,1 set ng in 2 cells
				# =2 set ng in 1 cell, fngx at interface
islbcp    integer      /2/	# b.c. for phi at limiter guard cells;
				# =0,1 set phi in 2 cells
				# =2 set phi in 1 cell, fqx at interface
isph_sput(ngspmx) integer /ngspmx*0/  #flag for plate sputtering; 
				#0=old fixed case; 1=DIVIMP/JET phys sputt fits
				#=2 adds h-ion chem sputt;=3 adds h-neut c_sput
isi_sputw(ngspmx) integer /ngspmx*0/ #flag for outer wall ion-based sputter; 
				#=0, no ion sputtering
				#=1 adds phys ion sputt; =2 adds chem ion sputt
isi_sputpf(ngspmx) integer /ngspmx*0/ #flag for priv flux ion-based sputter; 
				#=0, no ion sputtering
				#=1 adds phys ion sputt; =2 adds chem ion sputt
matt	  integer               #output flag from syld96 for sputt. target mat.
matp	  integer               #output flag from syld96 for sputt. plasma
cion      integer     /6/       #input to syld96; atom num. of sputt. target
cizb      integer     /1/       #input to syld96; max charge state of plasma
crmb	  real        /2./[AMU] #input to syld96; mass of plasma ions
isch_sput(ngspmx) integer /ngspmx*0/ #chem sputt. opt; 0=old; 
			       #5=Roth,G-R; 6=Haasz97; 7=Haasz97+Davis at low E
eincid    real         [eV]     #incident energy of ion or neut. for chem sputt
t_wall    real       /300./ [K] #temp. of side wall
t_plat    real       /300./ [K] #temp. of divertor plate
flux_in   real        [1/m**2s] #incident ion or neutral flux for chem sputt
ychem     real                  #chem sputt. yield output from sputchem
yld_carbi(0:nx+1) _real         #chem sputt. yield, inner wall if isch_sput=5,6
yld_carbo(0:nx+1) _real         #chem sputt. yield, outer wall if isch_sput=5,6
fchemywi  real       /1./ #factor mult. pf wall chem yield if isch_sput>0
fchemylb(nxptmx)  _real    /1./   #fact mult. inner plate chem yield if isch_sput>0
fchemyrb(nxptmx)  _real    /1./   #fact mult. outer plate chem yield if isch_sput>0
fchemywo  real       /1./ #factor mult. outer wall chem yield if isch_sput>0
fphysylb(nxptmx)  _real    /1./   #fact mult inner plate phys sput yield if isph_sput>0
fphysyrb(nxptmx)  _real    /1./   #fact mult outer plate phys sput yield if isph_sput>0
isexunif  integer      /0/      #=1 forces ex ~ uniform at div. plates
xcnearlb  logical    /FALSE/    #=TRUE if Jac'n "box" overlaps a left boundary
xcnearrb  logical    /FALSE/    #=TRUE if Jac'n "box" overlaps a right boundary
openbox   logical    /FALSE/    #=TRUE if Jac'n "box" is wide open
kappa0	  real       /3.0/	#modified sheath drop (allows j>jsat) for kappa > kappa0
kappamx   real       /10.0/	#maximum kappa value
fqpsatlb(0:ny+1,nxptmx)	_real	#ion saturation current at left boundary
fqpsatrb(0:ny+1,nxptmx)	_real	#ion saturation current at right boundary
cfueb		real	/1./	#scale factor for ueb in plate b.c.'s
ikapmod   integer	/0/	#=1 for new kappa model; =0 for qpfac model
fvapi(10) real		/10*0./	#scale factor for inner evap vapor source
avapi(10) real		/10*1./	#linear coeff. for inner evap vapor source
bvapi(10) real		/10*1./ #exponent coeff. for inner evap vapor source 
fvapo(10) real		/10*0./	#scale factor for outer evap vapor source
avapo(10) real		/10*1./	#linear coeff. for outer evap vapor source
bvapo(10) real		/10*1./ #exponent coeff. for outer evap vapor source 
tvapi(0:nx+1) _real [K]   	#inner wall temp for evap; input after alloc
tvapo(0:nx+1) _real [K]   	#outer wall temp for evap; input after alloc
cfvytanbc real          /1./    #factor for adding vytan to plate B.C.
totfeexl(0:ny+1,nxpt) _real [W] #elec polod energy flux*area on "left" plate
totfeexr(0:ny+1,nxpt) _real [W] #elec polod energy flux*area on "right" plate
totfeixl(0:ny+1,nxpt) _real [W] #elec polod energy flux*area on "left" plate
totfeixr(0:ny+1,nxpt) _real [W] #elec polod energy flux*area on "right" plate

***** Rccoef:
#Variables for recycling coeff. profiles on divertor plates
#Set for ngspmx gas species 
recylb(0:ny+1,ngspmx,nxptmx) _real       #inner plate recycling coeff. (calc)
recyrb(0:ny+1,ngspmx,nxptmx) _real       #outer plate recycling coeff. (calc)
recycp(ngspmx)   real       /.9,5*0./  #recycling coef at plates if ndatlb,rb=0
recycflb(nxptmx)   _real      /1./       #extra factor for recycling at ix=0
recycfrb(nxptmx)   _real      /1./       #extra factor for recycling at ix=nx+1
recycm           real       /0.1/      #momentum recycling/Rp for inertial gas;
				       #if recycm < -9.9, then d(up)/dx=0 used
recyce           real       /0./       #energy recycling/Rp for inertial gas
recycl           real       /1./       #recycling coef. at a limiter (ix_lim)
recycml          real       /0.1/      #momentum recycling/Rp for gas at limtr
recycc(ngspmx)   real       /6*1./     #core recycling coeff. if isnicore=3
albedoc(ngspmx)  real       /6*1./     #core neut albedo for isngcore=0
albedolb(ngspmx,nxptmx) _real /1./       #albedo at inner plate if ndatlb=0
albedorb(ngspmx,nxptmx) _real /1./       #albedo at outer plate if ndatrb=0
ndatlb(ngspmx,nxptmx)    _integer        #number of recycp data pts on inner plt
ndatrb(ngspmx,nxptmx)    _integer        #number of recycp data pts on outer plt
ydatlb(ngspmx,50,nxptmx) _real [m]  /0./ #inner data pt location from sep.
ydatrb(ngspmx,50,nxptmx) _real [m]  /0./ #outer data pt location from sep.
rdatlb(ngspmx,50,nxptmx) _real      /0./ #inner recycp data for each ydatlb
rdatrb(ngspmx,50,nxptmx) _real      /0./ #outer recycp data for each ydatrb
alblb(0:ny+1,ngspmx,nxptmx) _real        #inner plate albedo; used if <1 (calc)
albrb(0:ny+1,ngspmx,nxptmx) _real        #outer plate albedo; used if <1 (calc)
fngxslb(0:ny+1,ngspmx,nxptmx) _real [1/s]
#inner plate user gas sour. if sputtlb>0
fngxsrb(0:ny+1,ngspmx,nxptmx) _real [1/s]
#outer plate user gas sour. if sputtlb>0
adatlb(ngspmx,50,nxptmx) _real    /1./   #inner albdedo data for each ydati
adatrb(ngspmx,50,nxptmx) _real    /1./   #outer albdedo data for each ydati
recycw(ngspmx)   real     /ngspmx*1e-10/ #recycling coef. at side walls
sputtr           real       /0./         #sputtering coef. at plates
sputtlb(0:ny+1,ngspmx,nxptmx)    _real   #set sputt coef. inner plate (iy,igsp)
sputtrb(0:ny+1,ngspmx,nxptmx)    _real   #set sputt coef. outer plate (iy,igsp)
sputflxlb(0:ny+1,ngspmx,nxptmx)  _real   #calc sput flux inner plate (iy,igsp)
sputflxrb(0:ny+1,ngspmx,nxptmx)  _real   #calc sput flux outer plate (iy,igsp)
sputflxw(0:nx+1,ngspmx)          _real   #calc sput flux outer wall (ix,igsp)
sputflxpf(0:nx+1,ngspmx)         _real   #calc sput flux PF wall (ix,igsp)
ngplatlb(ngspmx,nxptmx)          _real   #ng on inner plate if sputti < -9.9
ngplatrb(ngspmx,nxptmx)          _real   #ng on outer plate if sputto < -9.9
ipsputt_s		integer /1/      #start dens-index phys sputt species
ipsputt_e		integer /1/      #end dens-index of phys sputt species

***** Fixsrc:
#Variables for including a fix-source at (xxsrc,yysrc) with int.=a*
ifixsrc     integer         /0/        #=1 turns on fixed Gaussian source
ifixpsor    integer         /0/        #=1 freezes part. source to initial val.
xxsrc       real            /3./
yysrc       real            /0.2/
c1n         real            /0./
c1e         real            /0./
c1i         real            /0./
a1n         real            /.5e+23/
a1e         real            /150.e+23/
a1i         real            /45.e+23/
b1n         real            /.1111/
b1e         real            /.1111/
b1i         real            /.1111/

***** Selec:
#Variables for the calculation of the Jacobian locally.
i1          integer
i2          integer
i3          integer
i4          integer
i5          integer
i6          integer
i7          integer
i8          integer
j1          integer
j2          integer
j3          integer
j4          integer
j5          integer
j6          integer
j7          integer
j8          integer
j1p         integer	#y-index lower range for potential eqn
j2p         integer	#y-index lower range for potential eqn
j5p         integer	#y-index upper range for potential eqn
j6p         integer	#y-index upper range for potential eqn
ixs1        integer
ixf6        integer
iys1        integer
iyf6        integer
xlinc       integer         /2/
xrinc       integer         /1/
yinc        integer         /2/
ixm1(0:nx+1,0:ny+1)       _integer
ixp1(0:nx+1,0:ny+1)       _integer
iym1a(0:nx+1,0:ny+1)      _integer  # for mdsplus use only
iyp1a(0:nx+1,0:ny+1)      _integer
stretcx(0:nx+1,0:ny+1)    _real      #array for stretching gas x-coord.

***** Aux:
#Variables for auxiliary storage.
ix          integer
iy          integer
igsp        integer
iv          integer
iv1         integer
iv2         integer
iv3         integer
ix1         integer
ix2         integer
ix3         integer
ix4         integer
ix5         integer
ix6         integer
ixmp 	    integer		# poloidal index of outer midplane; for yyc,f
tv          real
t0          real
t1          real
t2          real
a           real

***** Err_msg_out restart:
#Controls for output of error messages
errmsgflag	integer	/1/	# =0 turns off error messages, =1 turns them on
errunit		integer	/6/	# output unit for error messages
				# (nksol ignores errunit, sending everything to 6)

***** Opt_input:
#provides optional input for vodpk and daspk through non-eraseable arrays
inopt          integer   /0/   #resets iopts for solvers (vodpk, daspk)
iworkin(1:25)  integer /25*0/  #optional integer array input for vodpk
rworkin(1:25)  real    /25*0./ #optional real array input for vodpk

***** Lsode:
#Parameters and variables for the solver routines (originally lsodpk)
runtim       real /1.e-7/     #time of first output; total time=runtim*trange
trange       real /1.e7/      #factor multiplying runtim to give total sim. time
neq          integer          #total number of equations over whole domain
jacflg       integer /1/      #flag for computing Jacobian in vodpk
jpre         integer /1/      #flag for using the preconditioning step in vodpk
rtolv(30)    real  /30*1.e-4/ #relative tol. vector used in convert.m
itol         integer /4/
itask        integer /1/
istate       integer /1/
iopts        integer /0/   #internally set to inopt, an input variable
mf           integer /24/  #vodpk flag: mf=21, full user J; mf=22,full lsode J
                           #mf=24, banded user J; mf=25, banded lsode J
idid         integer /0/
ires         integer /0/
ts           real    /0./  #start time for ODE solvers
tout         real	   #output times for ODE solvers
dtmax        real /1.e20/  #maximum allowed dt for daspk if info(7)=1
dtinit       real /1.e-10/ #starting dt for daspk if info(8)=1
maxpoly      integer /5/   #maximum polynomial power used in daspk timestepping
ipar(3)      integer  #integer parameter communication
rpar(1)      real     #real parameter communication
rtol(neqmx)  _real    #relative tol. used by solvers; rtol=rtolv(igrid)*tolbf
atol(neqmx)  _real    #absolute tolerance for lsode-like routines
yl(neqmx)    _real    #primary variables for ODE's
yldot(neqmx) _real    #time-derivatives of yl's; RHS of ODE's
delta(neqmx) _real
iextra(5)    integer
info(20)     integer /0,1,0,0,1,1,0,0,0,1, 1,1,0,0,1,0,0,1,0,0/ #set for daspk
		# info(1) =0, indicates start of new problem to initializd code
		# info(2) =0, rtol,atol scalar; = 1, rtol,atol vectors
		# info(3) =0, output only at tout; =1, output at intermed. t
		# info(4) =0, no restrict on t; =1, stop at t=tstop=rwork(1) 
		# info(5) =0, daspk gen Jac, only if info(12)=0; =1, ext Jac
		# info(6) =0, full mat sol, only if info(12)=0; =1, band sol
		#             iwork(1)=lbw, iwork(2)=ubw
		# info(7) =0, code sets dt_max; =1, rwork(2)=dt_max
		# info(8) =0, code sets dt_init; =1, rwork(3)=dt_init
		# info(9) =0, maxord=5; =1 iwork(3)=maxord (=<5)
		# info(10)=0, no constraints; =1, constr initial cond.;
		#             =2, constr Y>0; =3, options 1 & 2 added
		# info(11)=0, consist init cond; =1, calc init cond(alg + der)
		#             =2, calc init cond (use Y', calc Y)
		# info(12)=0, direct mat sol; =1, Krylov method
		# info(13)=0, default Krylov param; =1, iwork(24)=maxl, 
		#             iwork(25)=kmp, iwork(26)=nrmax; rwork(10)=eplidpk
                #             default Krylov and direct pram: rwork(16)=epnldpk
		# info(14)=0, proc after init; =1, stop after init, then 
		#             reset info(1)=0 to avoid recalc init
		#             (or info(14)=0 & info(11)=0 to avoid recalc init?)
		# info(15)=0, no Jac routine; =1 Jac provided
		# info(16)=0, err chk on all Y; =1, no err on alg Y
		# info(17)=0, init calc control default; =1,input init control
		# info(18)=0. no init print; =1, min print; =2, full print
		# info(19)    not specified
		# info(20)    not specified

eplidpk      real /5.e-2/  # optional input for daspk when info(13) = 1
                           # tolerance for linear Krylov iteration.
epnldpk      real /1.e0/   # optional input for daspk when info(13) = 1
                           # tolerance for Newton iteration convergence.

srtolpk      real /1.e-4/  #del=srtolpk*rtol for num. diff. (daspk,vodpk)
                           #Now set internally as srtolpk=del/rtolv
efacn        real /1.e0/   #scaling factor for Newton error test in vodpk
ftol         real /1.e-10/ #stop tolerance of su*f for nksol (=epsmch**(1/3))
                           #  ( maxnorm(f) .le. ftol to stop. )
stptol       real /0.e0/   #stop tolerance of yl(k)-yl(k-1) in nksol
                           #  ( maxnorm(yl(k)-yl(k-1)) .le. stptol to stop. )
epscon1      real /1.e-1/  #linear solve tolerance in nksol, epsfac =
                           # epscon1*min(epscon2,frnm)
epscon2      real /1.e-2/  #linear solve tolerance in nksol, epsfac =
                           # epscon1*min(epscon2,frnm)
iterm        integer     #output flag for nksol
mdif         integer /0/ #nksol flag for user-supplied j*v product (0=internal)
ipflag       integer /1/ #nksol flag to precondition (1=yes)
mfnksol      integer /-3/#nksol method flag; =1 means dogleg strategy,
                         #=2 means linesearch with Arnoldi method,
                         #=3 means linesearch with GMRES method.
                         #negative mfnksol ignores global constaints
iprint       integer /1/ #nksol optional statistics flag.
                         #=0 means no optional statistics are printed.
                         #=1 means iteration count, norm of F(u) and
                         #   no. of F evaluations are printed.
                         #=2 means irpint=1 statistics are printed, and
                         #   statistics regarding the convergence of the
                         #   Krylov iteration, dogleg strategy.  See
                         #   nksol documentation for more details.
itermx       integer /30/# maximum number of nonlinear iterations for nksol.
stepmx       real /1.e9/ # maximum length of a Newton step for nksol.
del2nksol    real /1.e-14/ # if nonzero, size of del**2 for diff. quot. Jac
taunksol     real /1.e9/ # initial size of trust region for dogleg strategy
                         # (mfnksol = 1) in nksol.
incpset      integer /5/ # maximum number of nonlinear iterations before
                         # the preconditioner is reevaluated within nksol.
ismmaxuc     integer /1/ #=1 for calc. mmaxu internally from nx and ny
mmaxu        integer /25/# maximum Krylov subspace dimension.
                         # currently, only used in nksol			                         # If ismmaxuc=1, calc. internally; ismmaxuc=0 use input
icntnunk     integer /0/ #nksol continuation call flag.
                         #=1 tells nksol not to call the preconditioner routine
                         #   pset on the current call.  In this case, nksol
                         #   assumes that the preconditioner was evaulated
                         #   on an earlier call, and is to be used for as
                         #   many steps as it is successful on this call.
                         #=0 tells nksol that this is not a continuation call.
                         #   The preconditioner routine pset is called to
                         #   evaluate and factor the Jacobian matrix.

***** Parallv:
#Variables used for the parallel version utilizing pvode or kinsol
nlocal       integer       #number of equations on given processor
neqg         integer       #total number of equations over all processors
meth         integer /2/   #input for fpvmalloc; spec. method (lmm)
itmeth       integer /2/   #input for fpvmalloc; spec. interation method (iter)
iatol        integer /1/   #input for fpvmalloc; spec. error array type
igs          integer /1/   #input for fcvspgrm2; Gram-Schmidt process
maxkd        integer /50/  #maximum Krylov dimension for kinsol
maxlrst      integer /2/   # for kinsol
msbpre       integer /0/   #preconditioner flag for kinsol
globalstrat  integer /0/   #global strategy flag for kinsol
iopt(40)     integer /40*0/#opt. input/output array
ropt(40)     real  /40*0./ #opt. input/output array
rtol_pv      real /1e-4/   #relative tol. for parallel pvode
atol_pv      real /1e-6/   #relative tol. for parallel pvode
delt_pv      real /5e-4/   #linear converg. error-test param. for pvode

***** Constraints:
#Variables for checking constraints, i.e., negativity
icflag          integer /1/ #flag to use constraint that ni, etc. not < 0
                            #=1 turns on for nksol(with rlx) and vodpk(no rlx)
                            #=2 adds rlx constraint to vodpk
rlx             real  /.4/  #fractional change allowed per iteration
rlxv            real  /.4/  #fractional change in up allowed for svrpkg=newton
icnstr(neqmx)  _integer     #nksol constraint array; =1 means must be > 0
constr(neqmx)  _real        #kinsol constraint array; =1 means must be > 0
ylprevc(neqmx) _real        #yl vector from previous call from vodpk
ylchng(neqmx)  _real        #change in yl from prev. step, yl-ylprevc
adjf1           real  /1.2/ #if mfnksol=3 glob strat, frnm_new/adjf1>=fnrm_old

***** Ynorm:
#Variables for the normalization of the y's:
iscolnorm	integer /3/	# =0 for no implicit scaling (suscal=1)
				# =1 for scaling by normalization constants
				# =2 for scaling by max(abs(yl),floors)
				# =3 combination of global scaling with nnorm,
                                #    etc, followed by local scaling by each yl
norm_cons(numvar)	_real	# normalization constants (calculated)
floor_cons(numvar)	_real	# floor constants (calculated)
var_scale_floor	  real	/1.e-7/ # factor from norm_c to floor_c except for up 
	# factor multiplied by normalization constants to get floors for scaling
vsf_up            real  /1.e0/  #var_scale_floor factor for up eqns
vsf_phi           real  /1.e0/  #var_scale_floor factor for phi eqns
n0(nispmx)        real  [m**-3] /nispmx*1.e20/ #normalization ion density
n0g(ngspmx)       real  [m**-3] /ngspmx*1.e20/ #normalization gas density
temp0           real  [eV]     /100./    #normalization temperature
isflxvar        integer        /0/       #sets variables for ODE, Jacobian
                                         #=1 for yl=n,nv,nT; =0 for yl=n,v,T
                                         #=2 for yl=n,v,nT 
isrscalf        integer        /1/       #rescales ODE rhs if isflxvar.ne.1
dx0             real  [m]      /30./     #norm. grid spacing factor for phi eqn
nnorm           real  [m**-3]            #normalization density(calc)
ennorm          real  [J/m**3]           #normalization energy density(calc)
sigbar0         real  [Mho/m]            #normalization parallel cond. (calc)
vpnorm          real  [m/s]              #normalization ion paral.velocity(calc)
fnorm(1:nusp)  _real  [1/m**2 s]         #normalization particle flux(calc)
suscal(neqmx)  _real      #scale factors for yl's in nksol routine (nominally=1)
sfscal(neqmx)  _real      #scale factors for f's in nksol routine (nominally=1)
rdoff           real /0./    #ranf-induced roundoff error compared to unity
yloext(neqmx)  _real         #last var for d(yl)/dt set externally
isyloext        integer /0/  #=1 allows d(yl)/dt using ext. yloext

***** Phyvar:
#Values of some physical constants
pi              real            /3.14159265358979323e0/ #Pi
me              real            /9.1096e-31/            #Electron mass
mp              real            /1.6726e-27/            #Proton mass
ev              real            /1.6022e-19/            #1 electron volt
qe              real            /1.6022e-19/            #Elementary charge
mu0             real            /1.25663706e-6/         #Vac. magnetic perm.
eps0            real            /8.8542e-12/            #Vac. dielectric perm.
rt8opi          real            /1.595769121606e0/      #sqrt(8/pi)

***** Comtra restart:
#Variables that contain the transport parameters.
parvis(1:nispmx)  real          /nispmx*1./     #factor times parallel visc.
travis(1:nispmx)  real [m**2/s] /nispmx*1./     #value of perp. visc.
difni(1:nispmx)   real [m**2/s] /nispmx*0.5/    #value of density radial diff. coef.
difax(1:nispmx)   real [m**2/s] /nispmx*0./     #poloid. diff coeff.,scaled with dn/dx
difnit(1:nispmx)  real [none]   /nispmx*0./     #turb. radial diff. multiplier
cdifnit           real [none]   /1./            #=1 for all turb., =0 all fixed, D coef
difpr(1:nispmx)   real [m**2/s] /nispmx*0./     #value of pressure radial diff. coef.
difni2(1:nispmx)  real [m**2/s] /nispmx*0./     #value of density e_ll x e_r diff. coef.
difpr2(1:nispmx)  real [m**2/s] /nispmx*0./     #value of pressure e_ll x e_r diff. coef
difutm(1:nispmx)  real [m**2/s] /nispmx*1./     #value of toroidal mom. diff. coef
difniv(0:ny+1,1:nisp)  _real [m**2/s]   /0./	#dens diff. if isbohmcalc=3, varys w/B
difprv(0:ny+1,1:nisp)  _real [m**2/s]   /0./	#press diff if isbohmcalc=3, varys w/B
difniv2(0:ny+1,1:nisp) _real [m**2/s]   /0./	#dens2 diff. if isbohmcalc=3, varys w/B
travisv(0:ny+1,1:nisp) _real [m**2/s]   /0./	#viscosity. if isbohmcalc=3, varys w/B
kyev(0:ny+1)	_real [m**2/s]   /0./	#elec eng chi if isbohmcalc=3, vary(0:ny+1)s w/B
kyiv(0:ny+1)	_real [m**2/s]   /0./	#ion eng chi if isbohmcalc=3, varys w/B
difutmv(0:ny+1,1:nisp)	_real [m**2/s]   /0./	#dens diff. if isbohmcalc=3, varys w/B
vconyv(0:ny+1,1:nisp) _real [m/s] /0./   #convec radial vel if isbohmcalc=3
inbtdif		real		 /2/	#if isbohmcalc=3, D,chi ~1/Bt**inbtdif
inbpdif		integer		 /1/	#if isbohmcalc=3, D,chi ~1/Bp**inbpdif
ixbpmin         integer          /0/    #isbohmcalc=3, min bpol(ixpt2-ixbpmin,
isbohmcalc      integer          /1/	#if=1, calc Bohm diff if facb... > 0
					#if=2, harmonic ave of Bohm, difni, etc.
					#if=3, D=difniv*(B0/B)**inbdif, etc
facbni        real [ ]      /0./	#factor for Bohm density y-diff. coeff.
facbup        real [ ]      /0./	#factor for Bohm parll v y-diff. coeff.
facbni2       real [ ]      /0./	#factor for Bohm density 2-diff. coeff.
facbee        real [ ]      /0./	#factor for Bohm Te diff. coeff.
facbei	      real [ ]      /0./	#factor for Bohm Ti diff. coeff.
vcony(1:nispmx) real [m/s] /nispmx*0./  #value of constant radial velocity
difcng	      real [m**2/s] /50./       #constant gas diff. coeff if isgasdc=1
isgasdc       integer       /0/         #switch to turn on constant gas dif coef
flalfe        real          /1e20/      #|| heat flux limit factor for elec.
flalfi        real          /1.e+10/    #|| heat flux limit factor for ions
flalftf	      real          /1.e20/     #elec. thermal force flux-lim factor
flgam         real          /1./        #exponent for ion flux-limit expression
flgamv        real          /1./        #exponent for vel flux-limit expression
flgamg        real          /2./        #exponent for gas dens flux-limit 
flgamvg       real          /1./        #exponent for gas visc flux-limit
flgamtg       real          /1./        #exponent for gas temp flux-limit
fricflf       real          /1./        #flux-limiting factor for inputs to
                                        #multispecies friction (and upi) calc
isflxlde      integer       /0/         #=1,elec flux limit diff;=0, conv/diff
isflxldi      integer       /2/         #=1,ion flux limit diff;=0, conv/diff
                                        #=2, diff on individ hxcij
kxe           real          /1./        #poloidal electron heat diff. multi. fac
alfkxi        real          /0./        #reduces ion thermal conduc, K_||, if 
                                        #|ti(ix+1)-ti(ix)|<alfkxi*ti(ix)
alfkxe        real          /0./        #reduces elec thermal conduc, K_||, if 
                                        #|te(ix+1)-te(ix)|<alfkxe*te(ix)
kxecore       real          /1./        #poloidal elec heat diff. factor in core
kye           real [m**2/s] /0.7/       #radial electron heat diffusivity
kyet          real [none]   /0./        #turb. radial elec. heat diff. multiplier
ckyet         real [none]   /1./        #=1 for all turb., =0 all fixed, chi_e
kxi           real          /1./        #poloidal ion heat diff. multi. fac
kxicore       real          /1./        #poloidal ion heat diff. factor in core
kxn           real          /0./        #poloidal cx-neutral heat diff. factor
kyi           real [m**2/s] /.2/        #radial ion heat diffusivity
kyit          real [none]   /0./        #turb. radial ion heat diff. multiplier
ckyit         real [none]   /1./        #=1 for all turb., =0 all fixed, chi_i
kyn           real          /0./        #radial cx-neutral heat diff. factor
feqp          real          /1./        #(Te-Ti) equipartition multiplier
alfeqp        real          /0./        #reduces equipart. term if te~ti
flalfgx(10)   real          /10*1.e10/  #poloidal gas diff. flux limit
flalfgy(10)   real          /10*1.e10/  #radial gas diff. flux limit
flalfgxy(10)  real          /10*1.e10/  #nonorthog poloidal-face gas flux limit
flalfgnx      real          /1.e20/
flalfgny      real          /1.e20/
gcfacgx	      real	    /1./	#mult tot conv gas x-flux at ix=0 & nx
gcfacgy	      real	    /1./	#mult tot conv gas y-flux at iy=0 & ny
gcfacgtx      real	    /0./	#mult grad Ti conv gas x-flux ix=0 & nx
gcfacgty      real	    /0./	#mult grad Ti conv gas y-flux iy=0 & ny
isdifxg_aug   integer       /0/         #=1 enhances D_xgas with flx-lim factor
isdifyg_aug   integer       /0/         #=1 enhances D_ygas with flx-lim factor
flalfv        real          /1.e+10/    #parallel velocity flux limit factor
isupdrag      integer       /0/         #=1 adds nonunif B-field drag on v_||
con_leng      real          /1e20/ [m]  #connect length used for coll trans fac
frac_pt       real          /0.3/       #invers aspect ratio for colliless drag
flalftgx      real          /1.e20/     #poloidal gas temp. diff. flux limit
flalftgy      real          /1.e20/     #radial gas temp. diff. flux limit
flalfvgx      real          /1.e20/     #poloidal gas parall viscosity flux lim
flalfvgy      real          /1.e20/     #radial gas parall viscosity flux limit
rnn2cx	      real          /0.2/       #ratio of neut-neut coll. to cx coll.
sigcx         real   [m**2] /1.e-18/    #cx cross-sect if icnucx=2
sigcxms(nisp,ngsp)   _real [m**2] /1e-19/ #cx x-sect for (ifld,igsp) coll
rcxighg(ngspmx) real      /ngspmx*0./   #ratio of charge-exchange rate for
                                        #ng_imp+ni_hydrn -> ng_hydrn+ni_Z=1_imp
kelighi(ngspmx) real [m**3/s]/0.,5*5e-16/#elastic coll. coeff:imp_gas+hyd_ion
kelighg(ngspmx) real [m**3/s]/0.,5*5e-16/#elastic coll. coeff:imp_gas+hyd_gas
keligii(ngspmx) real [m**3/s]/0.,5*5e-16/#elastic coll. coeff:imp_gas+imp_ion
cfmassfac       real         /1./       #scales elas scat factor 16mi/(3mg+mi)
sigvi_floor   real [m**3/s]  /0./       #minimum of ioniz. rates allowed(1e-18)
fupe_cur      real []        /1./       #=1 fixes cur err to upe for isimpon=6
diffusivity(0:nx+1,0:ny+1)  _real -restart
   # anomalous (turbulent) diffusivity (calculated during rhs eval)
diffusivwrk(0:nx+1,0:ny+1)  _real -restart
   # anomalous (turbulent) diffusivity (mixed w/difni using cdifnit)
diffusivloc(0:nx+1,0:ny+1)  _real -restart
   # anomalous (turbulent) diffusivity (local values for isturbcons=2)
cfnus_e         real       /1./   # factor mult nu_star_e for elec coll_fe
cfnus_i         real       /1./   # factor mult nu_star_i for ion coll_fi
coll_fe(0:nx+1,0:ny+1) _real      # nu_star_e/(1+nu_star_e) for elec CF drifts
coll_fi(0:nx+1,0:ny+1) _real      # nu_star_i/(1+nu_star_i) for ion CF drifts
tibsep	 	[eV] real /100./  # Ion temp on sep for banana width in lconi
tebsep	 	[eV] real /100./  # Elec temp on sep for banana width in lcone
cfelecbwd	     real /10./	  # Factor for elec banana width in lcone; makes
				  # elec banana width not to small for mesh
							      
***** Turbulence:
# Variables used in calculating anomalous diffusivities
kappabar      real [1/m]  /0.003/ # field-line avg'd curvature
lambdan       real [none]   /4./  # dens(divertor) / dens(midplane)
lambdat       real [none]   /4./  # temp(midplane) / temp(divertor)
gammasi       real [none]   /0./  # secondary emis. coef. from ion bombard.
lambdap       real [none]   /3.5/ # e (dPhi0 / dr0) / (dTed / dr0)
suppress_lmode   integer    /0/   # =1 to suppress L-mode turbulence in SOL
maxmag_lmode  real          /2./  # max magn. of step in bracketing kymax
nky           integer       /30/  # number of ky values in search for kymax
kybeg         real [none]  /0.05/ # lower limit of acceptable kymax
kyend         real [none]   /3./  # upper limit of acceptable kymax
kya           real [none]   /1.0/ # one initial point in search for kymax
kyb           real [none]   /1.1/ # other initial point in search for kymax
iprint_lmode  integer  /0/  # =1 for diagnostic output, =2 for more output
tol_lmode     real [none] /1.e-6/ # abs & rel tolerance in search for kymax
isturbnloc    integer  /1/  # =1 to turn on nonlocal dependence of D,chi
isturbcons    integer  /1/  # =1 to make turbulent D,chi const within SOL
                            # =2 to apply radial digital filter to D,chi
diffusrange   real [m]  /0.01/  # radial range of digital filter
diffuslimit   integer       # no. of surfaces in half-range of digital filter
diffuswgts(-9:9)  real [none]  # weights for radial digital filter
islmodebeta   integer  /1/  # =1 to turn on finite-beta correction
gradvconst    real [none] /0.005/ # factor involving rad. grad. of v(parallel)

***** Turbulence_comm:
# Communication of variables to minimization routine for turbulent growth rate
epsilon       real [none]         # rhos / lte
turbdelta     real [none]         # param. depending on temp. & length ratios
ssqthsqavg    real [none]   /1./  # field-line avg of s**2 * theta**2
kxconst       real [none]  /2.47/ # constant appearing in calc. of kx
cubrtnu       real [none]         # cube root of parameter nu
bcoef0        complex [none]
ccoef1        complex [none]
ccoef2        real [none]
ccoef3        real [none]

***** Turbulence_diagnostics:
chinorml(0:nx+1,0:ny+1)  _real # norm. anom. diffusivity (L-mode turbulence)
chinormh(0:nx+1,0:ny+1)  _real # norm. anom. diffusivity (H-mode turbulence)

***** Timary:
#Variables stored at output times for time-dependent calculations
nsteps     integer         /100/  #number of logarithmically spaced output times
nist1(nsteps,0:nx+1,0:ny+1,nisp) _real [1/m**3] #density for ODE output times
upst1(nsteps,0:nx+1,0:ny+1,nisp) _real [m/s]    #parallel vel for ODE output times
test1(nsteps,0:nx+1,0:ny+1)   _real [eV]     #Te at for ODE output times
tist1(nsteps,0:nx+1,0:ny+1)   _real [eV]     #Ti at for ODE output times
ngst1(nsteps,0:nx+1,0:ny+1,ngsp) _real [1/m**3] #ng at for ODE output times
phist1(nsteps,0:nx+1,0:ny+1)  _real [V]      #phi at various times
toutlsod(nsteps)              _real [s]      #time which nist1, etc, are filled
yldnmx(nsteps)                _real [1/s]    #max. rate-of-change, yldot/yl
iyldnmx(nsteps)               _integer       #index of vector yldnmx
istep_nk                       integer  /0/  #array index for time-dep. nksol
nsteps_nk                      integer  /1/  #number of nksol time-steps

***** Compla:
#Variables in common -- plasma parameters
mi(1:nisp)                 _real [kg]     #ion mass in kg, calculated from minu
zi(1:nisp)                 _real [ ]      #ion charge number, calc. from ziin
mg(1:ngsp)                 _real [kg]	  #gas species mass in kg, calc. fr minu
facmg(1:nispmx)                 real /nispmx*1./  #scale factor for mg to recov old case
znucl(1:nisp)              _integer [ ]   #tot. nucl. charge, calc. from znuclin
ni(0:nx+1,0:ny+1,1:nisp)   _real  [m^-3]  #ion density in primary cell (ix,iy)
lni(0:nx+1,0:ny+1,1:nisp)  _real  [m^-3]  #log(ion dens) in prim. cell (ix,iy)
nm(0:nx+1,0:ny+1,1:nisp)   _real [kg*m^-3]#mass density [nm(,,1) is sum, exclud.
                                          #gas, if nusp=1, isimpon=5] in cell
nz2(0:nx+1,0:ny+1)         _real  [m^-3]  #sum of ni*zi**2 over all ion species
uu(0:nx+1,0:ny+1,1:nisp)   _real  [m/s]   #ratio ion-flux/density at x-face;
                                          #if orthog mesh, poloidal ion velocity
uup(0:nx+1,0:ny+1,1:nisp)  _real  [m/s]   #poloidal ion vel (|| flow contrib)
up(0:nx+1,0:ny+1,1:nisp)   _real  [m/s]   #parallel ion velocity (mass-dens.
                                          # avg if isimpon = 5)
upi(0:nx+1,0:ny+1,1:nisp)  _real  [m/s]   #parallel ion velocity (individual
                                          # species if isimpon = 5)
uz(0:nx+1,0:ny+1,1:nisp)   _real  [m/s]   #toroidal ion vel in pol X rad direct
v2(0:nx+1,0:ny+1,1:nisp)   _real  [m/s]   #vel normal to parallel & rad. direc.
v2ce(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of v2 from ExB
v2cb(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of v2 from grad_B
ve2cb(0:nx+1,0:ny+1)       _real  [m/s]   #electron v2 from grad_B
v2cd(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of v2 from grad_PxB
v2rd(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of v2 from resistive drift
v2dd(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of v2 from anomalous drift
vy(0:nx+1,0:ny+1,1:nisp)   _real  [m/s]   #radial ion velocity
vytan(0:nx+1,0:ny+1,1:nisp)_real  [m/s]   #radial ion vel.*tan(vtag) on x-face 
vygtan(0:nx+1,0:ny+1,1:ngsp)_real [m/s]   #radial gas grad-T vel.*tan(vtag) on 
					  #x-face 
vyce(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of vy from ExB
vycb(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of vy from grad_B
veycb(0:nx+1,0:ny+1)       _real  [m/s]   #electron vy from grad_B
vycp(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #ion vy from grad_PixB
veycp(0:nx+1,0:ny+1)       _real  [m/s]   #electron vy from grad_PeXB
vyrd(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of vy from resistive drift
vydd(0:nx+1,0:ny+1,1:nisp) _real  [m/s]   #portion of vy from anomalous drift
vex(0:nx+1,0:ny+1)         _real  [m/s]   #Poloidal electron velocity
upe(0:nx+1,0:ny+1)         _real  [m/s]   #parallel electron velocity
vep(0:nx+1,0:ny+1)         _real  [m/s]   #old parallel electron velocity-remove
ve2(0:nx+1,0:ny+1)         _real  [m/s]   #old "2" electron velocity-remove
vey(0:nx+1,0:ny+1)         _real  [m/s]   #Radial electron velocity
vycf(0:nx+1,0:ny+1)	   _real  [m/s]   #radial vel from class. viscosity
vycr(0:nx+1,0:ny+1)	   _real  [m/s]   #radial vel from class. thermal force
te(0:nx+1,0:ny+1)          _real  [J]	  #electron temperature in primary cell
ti(0:nx+1,0:ny+1)          _real  [J]	  #ion temperature in primary cell
ng(0:nx+1,0:ny+1,1:ngsp)   _real  [m^-3]  #gas density in primary cell (ix,iy)
lng(0:nx+1,0:ny+1,1:ngsp)  _real  [m^-3]  #log(gas dens) in prim. cell (ix,iy)
uug(0:nx+1,0:ny+1,1:ngsp)  _real  [m/s]   #ratio gas-flux/density at x-face;
                                          #if orthog mesh, poloidal gas velocity
vyg(0:nx+1,0:ny+1,1:ngsp)  _real  [m/s]   #radial gas velocity
tg(0:nx+1,0:ny+1,1:ngsp)   _real  [J]	  #gas temperature in primary cell
istgcon(ngspmx)       real /ngspmx*0/ #=0, set tg(,,i)=rtg2ti*ti; if >0, set
                                      #tg=(1-istgcon)*rtg2ti*ti+istgcon*tgas*ev
tev(0:nx+1,0:ny+1)         _real  [J]	  #ion temperature at vertex of cell
tiv(0:nx+1,0:ny+1)         _real  [J]	  #ion temperature at vertex of cell
niy0(0:nx+1,0:ny+1,1:nisp) _real  [m^-3]  #ion density below y-face center
niy1(0:nx+1,0:ny+1,1:nisp) _real  [m^-3]  #ion density above y-face center
niy0s(0:nx+1,0:ny+1,1:nisp) _real [m^-3]  #old ion density below y-face center
niy1s(0:nx+1,0:ny+1,1:nisp) _real [m^-3]  #old ion density above y-face center
ney0(0:nx+1,0:ny+1)        _real  [m^-3]  #elec density below y-face center
ney1(0:nx+1,0:ny+1)        _real  [m^-3]  #elec density above y-face center
nity0(0:nx+1,0:ny+1)       _real  [m^-3]  #total ion density below y-face center
nity1(0:nx+1,0:ny+1)       _real  [m^-3]  #total ion density above y-face center
tey0(0:nx+1,0:ny+1)        _real  [eV]    #elec temp below y-face center
tey1(0:nx+1,0:ny+1)        _real  [eV]    #elec temp above y-face center
tiy0(0:nx+1,0:ny+1)        _real  [eV]    #ion temp below y-face center
tiy1(0:nx+1,0:ny+1)        _real  [eV]    #ion temp above y-face center
tiy0s(0:nx+1,0:ny+1)       _real  [eV]    #old ion temp below y-face center
tiy1s(0:nx+1,0:ny+1)       _real  [eV]    #old ion temp above y-face center
ngy0(0:nx+1,0:ny+1,1:ngsp) _real  [m^-3]  #gas density below y-face center
ngy1(0:nx+1,0:ny+1,1:ngsp) _real  [m^-3]  #gas density above y-face center
pgy0(0:nx+1,0:ny+1,1:ngsp) _real  [J/m^3] #gas pressure below y-face center
pgy1(0:nx+1,0:ny+1,1:ngsp) _real  [J/m^3] #gas pressure above y-face center
pg(0:nx+1,0:ny+1,1:ngsp)   _real  [J/m^3] #gas pressure at cell center
phiy0(0:nx+1,0:ny+1)       _real  [V]     #potential below y-face center
phiy1(0:nx+1,0:ny+1)       _real  [V]     #potential above y-face center
phiy0s(0:nx+1,0:ny+1)      _real  [V]     #old potential below y-face center
phiy1s(0:nx+1,0:ny+1)      _real  [V]     #old potential above y-face center
pr(0:nx+1,0:ny+1)          _real  [J/m^3] #total pressure at center of cell
prev(0:nx+1,0:ny+1)        _real  [J/m^3] #elec pressure at vertex of cell
prtv(0:nx+1,0:ny+1)        _real  [J/m^3] #total pressure at vertex of cell
pri(0:nx+1,0:ny+1,1:nisp)  _real  [J/m^3] #ion plasma pressure
priv(0:nx+1,0:ny+1,1:nisp) _real  [J/m^3] #ion pressure at vertex of cells
priy0(0:nx+1,0:ny+1,1:nisp) _real [J/m^3] #ion pressure below y-face center
priy1(0:nx+1,0:ny+1,1:nisp) _real [J/m^3] #ion pressure above y-face center
pre(0:nx+1,0:ny+1)         _real  [J/m^3] #el. plasma pressure
ne(0:nx+1,0:ny+1)          _real  [m^-3]  #electron dens in primary cell (ix,iy)
nit(0:nx+1,0:ny+1)         _real  [m^-3]  #tot ion dens in primary cell (ix,iy)
nginit(0:nx+1,0:ny+1)      _real  [m^-3]  #init gas dens in primary cell (ix,iy)
phi(0:nx+1,0:ny+1)         _real  [V]     #potential in primary cell (ix,iy)
phiv(0:nx+1,0:ny+1)        _real  [V]     #potential at vertex of cell
zeff(0:nx+1,0:ny+1)        _real  [ ]     #Z_effective charge in cell (ix,iy)
netap(0:nx+1,0:ny+1)       _real  [ ]     #ne*parallel resistivity
znot(0:nx+1,0:ny+1)        _real  [ ]     #=Sum(n_z * Z^2)/n_i in cell
zimpc(0:nx+1,0:ny+1)       _real  [ ]     #Zimp (avg-ion model) in cell (ix,iy)
nil(0:nx+1,0:ny+1,1:nisp)  _real  [m^-3]  #ion density at last output
upl(0:nx+1,0:ny+1,1:nisp)  _real  [m/s]   #parallel ion velocity at last output
tel(0:nx+1,0:ny+1)         _real  [J]	  #electron temperature at last output
til(0:nx+1,0:ny+1)         _real  [J]	  #ion temperature at last output
ngl(0:nx+1,0:ny+1,1:ngsp)  _real  [m^-3]  #gas density at last output
phil(0:nx+1,0:ny+1)        _real  [V]     #potential at last output
upxpt(1:nusp,1:nxpt)       _real  [m/s]   #parallel velocity at x-point
nixpt(1:nusp,1:nxpt)       _real  [m^-3]  #ion density at x-point
visyxpt(1:nusp,1:nxpt)     _real          #ion viscosity at x-point
vyhxpt(1:nusp,1:nxpt)      _real  [m/s]   #horiz. ion drift vel. at x-point
vyvxpt(1:nusp,1:nxpt)      _real  [m/s]   #vert. ion drift vel. at x-point
fmihxpt(1:nusp,1:nxpt)     _real  [Nwt]   #horiz. mom. flux at x-point
fmivxpt(1:nusp,1:nxpt)     _real  [Nwt]   #vert. mom. flux at x-point
rtauxfac                    real  /0./    #fac*rtaux, Ly-a optic depth to plate
					  #=1 standard; <=0 skips rtau calc.
rtauyfac                    real  /1./    #fac*rtauy, Ly-a optic depth to wall
rt_scal			    real  /1.e-16/#factor to scale rtaux,y & thus rtau
rtaux(0:nx+1,0:ny+1) _real [1e-16 m^-2]/0./ #Norm. poloidal neutral line-dens.,
					    #Ly-a opacity to plates
rtauy(0:nx+1,0:ny+1) _real [1e-16 m^-2]/0./ #Norm. radial neutral line-dens.,
					    #norm. Ly-a opacity to radial wall
rtau(0:nx+1,0:ny+1)  _real [1e-16 m^-2]/0./ #Min. norm neutral line-dens.,
					    #min. Ly-a  opacity; min(rtaux,rtauy)

***** Postproc:
#Variables used in the postprocessing of data to check energy and particle bal.
fetx(0:nx+1,0:ny+1)   _real [W]  #total energy flow through a poloidal cell face
fety(0:nx+1,0:ny+1)   _real [W]  #total energy flow through a radial cell face
pdrift(0:nx+1,0:ny+1) _real [W/m^3] #power in bringing new ion to flow velocity
peirad(0:nx+1,0:ny+1) _real [W]     #tot. power lost by electrons and ions in
                                    #rad., ion. and dissoc.
png2ni(0:nx+1,0:ny+1) _real [W]     #power exchange bwt. neutral and ion
pmomv(0:nx+1,0:ny+1)  _real [W/m^3] #power exchange bwt. neutal & ion from flow
jdote(0:nx+1,0:ny+1)  _real [W]     #power from J.E heating
engerr(0:nx+1,0:ny+1) _real         #local error in power balance
ptjdote                real [W]     #sum of J.E heating
ptigas                 real [W/m^3] #sum of png2ni heating
pvmomcx                real [W/m^3] #sum of pmomv heating
iion(ngsp)            _real [A]     #net ionization current per gas isotope
irecomb(ngsp)         _real [A]     #net recombination current of gas isotope
icxgas(ngsp)          _real [A]     #net charge exchange current of gas isotope
iion_tot               real [A]     #total ioniz. current over all isotopes
irecomb_tot            real [A]     #total recomb. current over all isotopes
icxgas_tot             real [A]     #total cx current over all gas isotopes
pradht                 real [W]     #total H photon rad. loss (- binding eng.)
pradiz                 real [W]     #ionization radiation energy loss
pradrc                 real [W]     #recombination radiation energy loss
pradimpt(ngsp)        _real [W]     #net impurity photon rad. loss
pradzbind              real [W]     #elec loss at imp ioniz carried as bind eng
pradimp(0:nzspmx,ngsp-1) _real [W]  #rad. loss for each impurity charge state
pbinde                 real [W]     #pwr stored in ion binding pot. eng. from ioniz.
pbindrc                real [W]     #binding eng. pwr released to elec. from recomb.
prdiss                 real [W]     #net photon pwr lost in dissoc.
pibirth                real [W]     #net ion energy gain from dissoc.
pwr_plth(0:ny+1,2*nxpt) _real [W/m**2]#hydrog rad pwr flux on divertor plate
pwr_pltz(0:ny+1,2*nxpt) _real [W/m**2]#impur rad pwr flux on divertor plate
pwr_wallh(0:nx+1)       _real [W/m**2]#hydrog rad pwr flux on outer wall
pwr_wallz(0:nx+1)       _real [W/m**2]#impur rad pwr flux on outer wall
sdelb(0:ny+1,1:nxpt)	_real [W/m**2]#elec pwr flux to left div
sderb(0:ny+1,1:nxpt)	_real [W/m**2]#elec ion pwr flux to right div
sdilb(0:ny+1,1:nxpt)	_real [W/m**2]#tot ion pwr flux to left div
sdirb(0:ny+1,1:nxpt)	_real [W/m**2]#tot ion pwr flux to right div
sbindlb(0:ny+1,1:nxpt)	_real [W/m**2]#tot bind eng pwr flux to left div
sbindrb(0:ny+1,1:nxpt)	_real [W/m**2]#tot bind eng pwr flux to right div
sdrlb(0:ny+1,1:nxpt)	_real [W/m**2]#tot rad pwr flux to left div
sdrrb(0:ny+1,1:nxpt)	_real [W/m**2]#tot rad flux to right div
sdtlb(0:ny+1,1:nxpt)	_real [W/m**2]#tot pwr flux to left div
sdtrb(0:ny+1,1:nxpt)	_real [W/m**2]#tot pwr flux to right div
gdilb(0:ny+1,nisp,nxpt) _real [1/m**2s]#particle flux to left div
gdirb(0:ny+1,nisp,nxpt) _real [1/m**2s]#particle flux to right div
engilb(0:ny+1,nisp,nxpt) _real [Volts] #ave ion energy to left div
engirb(0:ny+1,nisp,nxpt) _real [Volts] #ave ion energy to right div
gwalli(0:nx+1,nisp)     _real [1/m**2s]#particle flux to left div
engwalli(0:nx+1,nisp)   _real [Volts] #ave ion energy to outer wall
swallr(0:nx+1)		_real [W/m**2]#radiation pwr flux to outer wall
swalli(0:nx+1)		_real [W/m**2]#ion pwr flux to outer wall
swalle(0:nx+1)		_real [W/m**2]#elec pwr flux to outer wall
swbind(0:nx+1)		_real [W/m**2]#binding energy flux to outer wall
swallt(0:nx+1)		_real [W/m**2]#total pwr flux to outer wall

***** Volsrc:
#Parameters for volume particle, mom. & power sources for electrons and ions
pwrsore(0:nx+1,0:ny+1) _real [W]       #power src into electrons in cell ix,iy
pwrsori(0:nx+1,0:ny+1) _real [W]       #power src into ions in cell ix,iy
volpsor(0:nx+1,0:ny+1,1:nisp) _real [1/s]#current src into ions in cell ix,iy
volmsor(0:nx+1,0:ny+1,1:nisp) _real [kg m/s**2] #up mom src in cell ix,iy
voljcsor(0:nx+1,0:ny+1) _real [A]      #uniform core-region curr sor. in ix,iy
volpsorg(0:nx+1,0:ny+1,1:ngsp) _real [1/s]#curr source for gas in cell ix,iy
psgov_use(0:nx+1,0:ny+1,1:ngsp) _real [1/m**3 s]#user-specified gas source
jcvsor                  real [A]  /0./ #total core-region current for voljcsor
ix_sjcsor	        integer   /0/  #if nonzero, beginning ix for voljcsor
ix_ejcsor	        integer   /0/  #if nonzero, ending ix for voljcsor
iy_sjcsor	        integer   /0/  #if nonzero, beginning iy for voljcsor
iy_ejcsor	        integer   /0/  #if nonzero, ending iy for voljcsor
pvole                   real [W]  /0./ #total power into electrons
pvoli                   real [W]  /0./ #total power into ions
z0pe                    real [m]  /0./ #axial or x loc. of elec. power profile
z0pi                    real [m]  /0./ #axial or x loc. of ion power profile
r0pe                    real [m]  /0./ #radial or y loc. of elec. power profile
r0pi                    real [m]  /0./ #radial or y loc. of ion power profile
zwpe                    real [m] /3./  #axial or x Gauss. 1/2 width of e-power
zwpi                    real [m] /3./  #axial or y Gaussian 1/2 width ion power
rwpe                    real [m] /.05/ #rad. or x Gaussian 1/2 width e-power
rwpi                    real [m] /.05/ #rad. or y Gaussian 1/2 width ion power
ivolcur(1:nisp)        _real [A]  /0./ #total volume current
mvolcur(1:nisp)        _real [kgA m/s] /0./ #total volume parallel mom. curr.
z0ni                    real [m]  /0./ #axial or x loc. of ion particle profile
r0ni                    real [m]  /0./ #rad. or y loc. of ion particle profile
zwni                    real [m] /3./  #axial or y Gaussian 1/2 width ion prtcl
rwni                    real [m] /.05/ #rad. or y Gaussian 1/2 width ion prtcl
z0up                    real [m]  /0./ #axial or x loc. of ion mom. profile
r0up                    real [m]  /0./ #rad. or y loc. of ion mom. profile
zwup                    real [m] /3./  #axial or y Gaussian 1/2 width ion mom.
rwup                    real [m] /.05/ #rad. or y Gaussian 1/2 width ion mom.
thetarot		real [rad]/0./ #rotation angle for R,Z with effec. R,Z
		                       # R_e= R0+(R-R0)cos(th)+(Z-Z0)sin(th), 
		                       # Z_e= Z0-(R-R0)sin(th)+(Z-Z0)cos(th), 
rcutmin			real [m] /0./  #source zero if R<rcutmin
zcutmin			real [m] /0./  #source zero if Z<zcutmin
effvng(1:ngsp)	       _real [m] /0./  # normalizing factor of gas source; calc
ivolcurg(1:ngsp)       _real [A] /0./  #tot. volumn gas source strength
z0ng(1:ngsp)	       _real [m] /0./  #axial or x loc. of gas particle profile
r0ng(1:ngsp)           _real [m] /0./  #rad. or y loc. of gas particle profile
zwng(1:ngsp)           _real [m] /3./  #axial or y Gaussian 1/2 width gas prtcl
rwng(1:ngsp)           _real [m] /.05/ #rad. or y Gaussian 1/2 width gas prtcl

***** Bfield:
#Variables for the B-field and grad_B drift geo/B-field factors
b0                     real /1./ +restart
                                 #scale factor for magnetic field
b02d(0:nx+1,0:ny+1)   _real      #net B-field scale fac. =b0+b0_use present iter.
b0old(0:nx+1,0:ny+1)  _real      #net B-field scale factor at last iter.
b0_use(0:nx+1,0:ny+1) _real      #spatial B-field scale factor; user input
rbpol(0:nx+1,0:ny+1)  _real [mT]    #major radius*poloidal magnetic field
btot(0:nx+1,0:ny+1)   _real [T]     #total magnetic field strength
rbfbt(0:nx+1,0:ny+1)  _real [ ]     #ratio bphi/btot at density cell center
rbfbt2(0:nx+1,0:ny+1) _real [1/T]   #ratio bphi/btot**2 at density cell center
curvrby(0:nx+1,0:ny+1) _real [1/mT] #curvature drift factor on y-face
curvrb2(0:nx+1,0:ny+1) _real [1/mT] #curvature drift factor on x-face
gradby(0:nx+1,0:ny+1)  _real [1/mT] #grad_B drift (p_perp) drift factor, y-face
gradb2(0:nx+1,0:ny+1)  _real [1/mT] #grad_B drift (p_perp) drift factor, x-face

***** Oldpla:
#Old value of some of the plasma quantities.
ni0(0:nx+1,0:ny+1,1:nisp)  _real [m^-3]  #old ion density
ng0(0:nx+1,0:ny+1,1:ngsp)  _real [m^-3]  #old neutral density
te0(0:nx+1,0:ny+1)         _real [J]     #old electron temperature 
ti0(0:nx+1,0:ny+1)         _real [J]     #old ion temperature
phi0(0:nx+1,0:ny+1)        _real [V]     #old electrostatic potential
up0(0:nx+1,0:ny+1,1:nisp)  _real [m/s]   #old parallel velocity
vy0(0:nx+1,0:ny+1,1:nisp)  _real [m/s]   #old radial velocity

***** Comflo:
#Variables in common -- flows
fqp(0:nx+1,0:ny+1)         _real [Amp]  #pol proj of par cur, east face
fq2(0:nx+1,0:ny+1)         _real [Amp]  #pol proj of 2 cur, east face
fqx(0:nx+1,0:ny+1)         _real [Amp]  #net poloidal current, east face
fqxb(0:nx+1,0:ny+1)        _real [Amp]  #poloidal cur from grad_B, east face
fdiaxlb(0:ny+1,1:nxpt)     _real [Amp]  #left boundary Dia current for bc
fdiaxrb(0:ny+1,1:nxpt)     _real [Amp]  #right boundary Dia current for bc
floxebgt(0:nx+1,0:ny+1)    _real [W]    #BxgradTe diamag part floxe (-> feex)
floxibgt(0:nx+1,0:ny+1,1:nisp) _real [W]#BxgradTi diamag part floxi (-> feex)
fqy(0:nx+1,0:ny+1)         _real [Amp]  #net radial current, north face
fqyb(0:nx+1,0:ny+1)        _real [Amp]  #radial current from grad_B, north face
fqyn(0:nx+1,0:ny+1)        _real [Amp]  #radial cur from cx coll, north face
fqym(0:nx+1,0:ny+1)        _real [Amp]  #radial cur from inertia, north face
fqya(0:nx+1,0:ny+1)        _real [Amp]  #anomalous visc rad cur, north face
fqydt(0:nx+1,0:ny+1)       _real [Amp]  #time-dep inertial rad cur, north face
fqyao(0:nx+1,0:ny+1)       _real [Amp]  #old anom mobil rad current, north face
fqyd(0:nx+1,0:ny+1)        _real [Amp]  #diamag radial current; north face
fq2d(0:nx+1,0:ny+1)        _real [Amp]  #diamag 2-current; east face
fnix(0:nx+1,0:ny+1,1:nisp) _real [1/s]  #ion poloidal current, east face
fnixcb(0:nx+1,0:ny+1,1:nisp) _real [1/s]  #ion grad-B pol. current, east face
fniy(0:nx+1,0:ny+1,1:nisp) _real [1/s]  #ion radial current, north face
fniycb(0:nx+1,0:ny+1,1:nisp) _real [1/s]  #ion  grad-B rad. current, north face
flnix(0:nx+1,0:ny+1,1:nisp) _real [1/s] #ion poloidal log-current, east face
flniy(0:nx+1,0:ny+1,1:nisp) _real [1/s] #ion radial log-current, north face
fmix(0:nx+1,0:ny+1,1:nusp) _real [Nwt]  #ion poloidal momentum current,east face
fmiy(0:nx+1,0:ny+1,1:nusp) _real [Nwt]  #ion radial momentum current, north face
fmity(0:nx+1,0:ny+1,1:nusp) _real [Nwt/m ] #rad flux of E/B & gradB contrib. to
                                           #tor. ang mom; cell ctr.
fmixy(0:nx+1,0:ny+1,1:nusp) _real [Nwt] #nonorthog ion pol. mom. curr., east f.
feex(0:nx+1,0:ny+1)        _real [J/s]  #poloidal electron thermal current,
                                         #east face
feey(0:nx+1,0:ny+1)        _real [J/s]  #radial electron thermal current,
                                         #north face
feexy(0:nx+1,0:ny+1)       _real [J/s]  #nonorthog elec. pol. therm cur, east f.
feix(0:nx+1,0:ny+1)        _real [J/s]  #poloidal ion thermal current, east face
feiy(0:nx+1,0:ny+1)        _real [J/s]  #radial ion thermal current, north face
fniycbo(0:nx+1,1:nisp)     _real [1/s]  #fniy cor. iy=0 bdry for grad_B, grad_P
feiycbo(0:nx+1)            _real [J/s]  #feiy cor. iy=0 bdry for grad_B, grad_P
feeycbo(0:nx+1)            _real [J/s]  #feey cor. iy=0 bdry for grad_B, grad_P
feixy(0:nx+1,0:ny+1)       _real [J/s]  #nonorthog ion pol. thermal cur, east f.
fngx(0:nx+1,0:ny+1,1:ngsp)  _real [1/s] #neutral polodial current, east face
flngx(0:nx+1,0:ny+1,1:ngsp) _real [1/s] #neutral pol. log-current, east face
fngxs(0:nx+1,0:ny+1,1:ngsp) _real [1/s] #neutral pol cur w/o fngxy, east face
fngy(0:nx+1,0:ny+1,1:ngsp)  _real [1/s] #neutral radial current, north face
flngy(0:nx+1,0:ny+1,1:ngsp) _real [1/s] #neutral radial log-current, north face
fngxy(0:nx+1,0:ny+1,1:ngsp) _real [1/s] #nonorthog gas pol. cur., east face
flngxy(0:nx+1,0:ny+1,1:ngsp) _real [1/s] #nonorthog gas pol.log-cur., east face
fngyx(0:nx+1,0:ny+1,1:ngsp) _real [1/s] #nonorthog gas rad. cur., north face
 
***** Indexes:
#Indices that help the calculation
idxn(0:nx+1,0:ny+1,1:nisp)	_integer  # index of yl vector for ni(ix,iy)
idxg(0:nx+1,0:ny+1,1:ngsp)	_integer  # index of yl vector for ng(ix,iy)
idxu(0:nx+1,0:ny+1,1:nusp)	_integer  # index of yl vector for up(ix,iy)
idxti(0:nx+1,0:ny+1)		_integer  # index of yl vector for ti(ix,iy)
idxte(0:nx+1,0:ny+1)		_integer  # index of yl vector for te(ix,iy)
idxphi(0:nx+1,0:ny+1)		_integer  # index of yl vector for phi(ix,iy)
igyl(neqmx,2)			_integer  # ix,iy indices for vector yl(iv)
iseqalg(neqmx)                  _integer  # flag(=1) for eqn being algebraic
isvarup(numvar)			_integer  # flag(=1) for variable being up
isvarphi(numvar)		_integer  # flag(=1) for variable being phi

***** Stat:
#Variables for statistics of solver performance
hu(nsteps,ngrid)   _real    [1/s]  #present timestep
gpe(nsteps,ngrid)  _real           #ratio, linear to nonlinear iter, nli/nni 
npe(nsteps,ngrid)  _integer        #cumulative number of precond. eval.
nps(nsteps,ngrid)  _integer        #cumulative number of precond. solves
nfe(nsteps,ngrid)  _integer        #cumulative number of RHS eval.
nst(nsteps,ngrid)  _integer        #cum. number of steps taken
nni(nsteps,ngrid)  _integer        #cumulative number of nonlinear iter.
nli(nsteps,ngrid)  _integer        #cumulative number of linear iter.
nje(nsteps,ngrid)  _integer        #cumulative number of Jacobian eval.
ncfn(nsteps,ngrid) _integer        #number of nonlinear converg. failures
ncfl(nsteps,ngrid) _integer        #number of linear converg. failures
nqu(nsteps,ngrid)  _integer        #method order last used
iddas(nsteps,ngrid)  _integer      #idid for daspk
eqmxer(nsteps,ngrid) _integer      #eqn. number giving maximum error in lsode
lacor               integer        #location in rwork where error vector begins
lewt                integer        #location in rwork where ewt**-1 begins
npsn(ngrid)        _integer        #cum. number of Jacobian solves for Newton
njen(ngrid)        _integer        #cum. Jacobian evals. for Newton iter.

***** Poten:
#Variables required for the calculation of the potential.
newbcl(nxptmx)     integer /nxptmx*0/ +restart #switch on new sheath model
newbcr(nxptmx)     integer /nxptmx*0/ +restart #switch on new sheath model
iskaplex           integer /0/  #=1 if kappal is set externally (from parser)
iskaprex           integer /0/  #=1 if kappar is set externally (from parser)
bcee               real  /4./ +restart
                                #electron sheath energy trans. factor(newbc=0)
bcei               real  /2.5/ +restart
                                #ion sheath energy trans. factor(newbc=0)
bceew              real  /4./   #elec wall energy trans factor
bceiw              real  /2.5/  #ion wall energy trans factor
bcen               real  /0./ +restart
                                #neutral sheath energy trans. factor(newbc=0)
                                #For combined neutral+ion energy equation
isfdiax            real  /0./   #switch to turn on diamagnetic drift for sheath
				#potential calculation
cthe               real  /0.71/ #electron thermal force coeff.
cthi               real  /4.05/ #?ion thermal force coeff.?; enters if zeff.ne.1
sigma1             real [1/(eV**1.5_Ohm_m)] /1490./#parallel conductivity coeff.
                        #sigma1=1/(5.19e-5*Z*ln_lambda) & Z=1, ln_lambda=12.9
cfsigm		   real   /1./  #scale factor for parallel cond. sigma1
rsigpl             real  /0./ +restart
                                #ratio of perp to parallel conductivity
bcel(0:ny+1,nxpt)      _real  [ ]   #electron sheath energy transmission factor
                                    #on the left boundary
bcer(0:ny+1,nxpt)      _real  [ ]   #electron sheath energy transmission factor
                                    #on the right boundary
bcil(0:ny+1,nxpt)      _real  [ ]   #ion sheath energy transmission factor
                                    #on the left boundary
bcir(0:ny+1,nxpt)      _real  [ ]   #ion sheath energy transmission factor
                                    #on the right boundary
kappal(0:ny+1,nxpt)  _real  [ ]	#sheath pot'l drop on left  boundary, phi/Te
kappar(0:ny+1,nxpt)  _real  [ ]	#sheath pot'l drop on right boundary, phi/Te
bctype(0:ny+1)    _integer #/0,ny*0,0/
phi0r(0:ny+1,nxpt)	_real [V] /0./ #plate pot'l at right poloidal boundary
phi0l(0:ny+1,nxpt)	_real [V] /0./ #plate pot'l at left  poloidal boundary
capx(1:ny)        _real    #/ny*0.0/
dphi_iy1(0:nx+1)  _real [V] #/(nx+2)*0./  #incremental phi at iy=1 to have 
                                          #Te=constant for second phi BC
kincorlb(0:ny+1,nxpt)   _real [ ]   # kinetic corr. factor for elec part. loss, left b
kincorrb(0:ny+1,nxpt)   _real [ ]   # kinetic corr. factor for elec part. loss, right b
cfkincor            real     [ ] /0.5/ # factor for kincorlb,rb denom. factor
#Variables for the grid-sequencing.
#yet to be defined?

***** Gradients:
#Gradients of the different physical quantities.
ex(0:nx+1,0:ny+1)           _real  [V/m]  #poloidal electric field
ey(0:nx+1,0:ny+1)           _real  [V/m]  #radial electric field
einduc			     real  [V/m]  #inductive tor. E-field - input
gpix(0:nx+1,0:ny+1,1:nisp)  _real  [Pa/m] #X-gradient of ion pressure
gpiy(0:nx+1,0:ny+1,1:nisp)  _real  [Pa/m] #Y-gradient of ion pressure
gpex(0:nx+1,0:ny+1)         _real  [Pa/m] #X-gradient of el. pressure
gpey(0:nx+1,0:ny+1)         _real  [Pa/m] #Y-gradient of el. pressure
gprx(0:nx+1,0:ny+1)         _real  [Pa/m] #X-gradient of total pressure
gpry(0:nx+1,0:ny+1)         _real  [Pa/m] #Y-gradient of total pressure
gtex(0:nx+1,0:ny+1)         _real  [J/m]  #X-gradient of el. temperature
gtey(0:nx+1,0:ny+1)         _real  [J/m]  #Y-gradient of el. temperature
gtix(0:nx+1,0:ny+1)         _real  [J/m]  #X-gradient of ion temperature
gtiy(0:nx+1,0:ny+1)         _real  [J/m]  #Y-gradient of ion temperature

***** Cfric:
#Coulomb friction terms for parallel transport
frice(0:nx+1,0:ny+1)      _real [J/m**4]  #Electron parallel Coulomb friction
frici(0:nx+1,0:ny+1,nisp) _real [J/m**4]  #Ion parallel Coulomb friction
cfgti             /1./     real           #scale factor for ion thermal force
cfgte             /1./     real           #scale factor for elec. thermal force
cftaud            /1./     real           #scale factor for ion-ion drag time

***** Grid:
ngrid          /1/	 integer +regrid
ig                       integer
inewton(30)   /30*0/     integer  #=1 for Newton iter., =0 for time-dependent
                                  #reset=1 internally if svrpkg=nksol or newton
imeth            /0/     integer  #imeth=inewton(igrid)
nurlx           /1.e8/   real    [1/s] #rate coeff. to relax to boundary cond.
ijac(ngrid)             _integer
ijactot          /0/     integer  # tot Jac calcs, used as check when icntnunk=1

***** Wkspace:
#Workspace arrays
w(0:nx+1,0:ny+1)        _real
w0(0:nx+1,0:ny+1)       _real
w1(0:nx+1,0:ny+1)       _real
w2(0:nx+1,0:ny+1)       _real
w3(0:nx+1,0:ny+1)       _real

***** Locflux:
#Local arrays for the calculation of the fluxes and other quantities.
flox(0:nx+1,0:ny+1)     _real
floy(0:nx+1,0:ny+1)     _real
conx(0:nx+1,0:ny+1)     _real
cony(0:nx+1,0:ny+1)     _real
floxe(0:nx+1,0:ny+1)    _real
floye(0:nx+1,0:ny+1)    _real
floxi(0:nx+1,0:ny+1)    _real
floyi(0:nx+1,0:ny+1)    _real
floxg(0:nx+1,0:ny+1)    _real
floyg(0:nx+1,0:ny+1)    _real
fgtdx(0:nx+1)		_real	#scale factor for gas grad-x T vel
fgtdy(0:ny+1)		_real	#scale factor for gas grad-x T vel
conxe(0:nx+1,0:ny+1)    _real
conye(0:nx+1,0:ny+1)    _real
conxi(0:nx+1,0:ny+1)    _real
conyi(0:nx+1,0:ny+1)    _real
conxg(0:nx+1,0:ny+1)    _real
conyg(0:nx+1,0:ny+1)    _real

***** Conduc:
#Variables for the common -- conduc
visx(0:nx+1,0:ny+1,1:nisp)  _real [kg/m s]#poloidal viscosity coeff.
visy(0:nx+1,0:ny+1,1:nisp)  _real [kg/m s]#radial viscosity coeff.
hcxe(0:nx+1,0:ny+1)         _real [1/m s] #poloidal elec. therm. conduct.
hcye(0:nx+1,0:ny+1)         _real [1/m s] #radial elec. therm. conduct.
hcxij(0:nx+1,0:ny+1,1:nisp) _real [1/m s] #j-species pol. ion therm. conduct.
hcyij(0:nx+1,0:ny+1,1:nisp) _real [1/m s] #j-species rad. ion therm. conduct.
hcxi(0:nx+1,0:ny+1)         _real [1/m s] #summed pol. ion+neut therm. conduct.
hcyi(0:nx+1,0:ny+1)         _real [1/m s] #summed rad. ion+neut therm. conduct.
hcxn(0:nx+1,0:ny+1)         _real [1/m s] #poloidal neutral therm. conduct.
hcyn(0:nx+1,0:ny+1)         _real [1/m s] #radial neutral therm. conduct.
kxbohm(0:nx+1,0:ny+1)	    _real [m**2/s]#spatially depend. diff. on x-face
					  #set by user; Bohm if isbohmcalc=1
kybohm(0:nx+1,0:ny+1)	    _real [m**2/s]#spatially depend. diff. on y-face
					  #set by user; Bohm if isbohmcalc=1
vybohm(0:nx+1,0:ny+1)       _real [m/s]   #spatially depend. convect. y-vel
					  #set user if isbohmcalc=0; else =0
dif_use(0:nx+1,0:ny+1,1:nisp) _real [m**2/s]#spatially depend. diff; if
					  #isbohmcalc=1, user input if all
					  #facbni+facbup+facbee+facbei =0,
					  # or kybohm if facbni, etc. > 0; 
					  # if isbohmcalc=2, then
					  # D = difni*kybohm/(difni+kybohm)
difp_use(0:nx+1,0:ny+1,1:nisp) _real [m**2/s]#for gen pr diff; see dif_use comment
dif2_use(0:nx+1,0:ny+1,1:nisp) _real [m**2/s]#for dif2; see dif_use comment
tra_use(0:nx+1,0:ny+1,1:nisp) _real [m**2/s]#for travis; see dif_use comment
kye_use(0:nx+1,0:ny+1)        _real [m**2/s]#for kye; see dif_use comment
kyi_use(0:nx+1,0:ny+1)        _real [m**2/s]#for kyi; see dif_use comment
dutm_use(0:nx+1,0:ny+1,1:nisp) _real [m**2/s]#for difutm; see dif_use comment
vy_use(0:nx+1,0:ny+1,1:nisp) _real [m/s]  #user-set rad vel;for isbohmcalc=0
vyup_use(0:nx+1,0:ny+1)     _real  [m/s]  #user-set conv vel of ion || vel, up
vyte_use(0:nx+1,0:ny+1)     _real  [m/s]  #user-set rad elec eng vel
vyti_use(0:nx+1,0:ny+1)     _real  [m/s]  #user-set rad ion eng vel
fniyos_use(0:nx+1,0:ny+1,1:nisp) _real [1/s m**2] #user-set particle flux
feeyosn_use(0:nx+1,0:ny+1)    _real  [J/s m**2]    #user-set Te energy flux
feiyosn_use(0:nx+1,0:ny+1)    _real  [J/s m**2]    #user-set Ti energy flux
vy_cft(0:nx+1,0:ny+1,1:nisp) _real [m/s]  #calc vy from fniyos_use (fix flux)
vyte_cft(0:nx+1,0:ny+1)     _real  [m/s]  #calc vyte from feeyos_use (fix flux)
vyti_cft(0:nx+1,0:ny+1)     _real  [m/s]  #calc vyte from feiyos_use (fix flux)
nuiz(0:nx+1,0:ny+1,ngsp)    _real  [1/s]  #ionization rate (=ne*sigma*v) 
nucx(0:nx+1,0:ny+1,ngsp)    _real  [1/s]  #charge-exchg rate for neut(sigv*ni)
nucxi(0:nx+1,0:ny+1,nisp)   _real  [1/s]  #charge-exchg rate for ion (sigv*ng)
nueli(0:nx+1,0:ny+1,nisp)   _real  [1/s]  #elast scatt rate for ion (sigv*ng)
nuelg(0:nx+1,0:ny+1,ngsp)   _real  [1/s]  #elast scatt rate for gas (sigv*nimp)
nuix(0:nx+1,0:ny+1,ngsp)    _real  [1/s]  #fnuizx*nuiz+fnucxx*nucx
fnuizx                       real    /1./ #fraction of nuiz in nuix (see nuix)
fnucxx                       real    /1./ #fraction of nucx in nuix (see nuix)
nurc(0:nx+1,0:ny+1,ngsp)    _real  [1/s]  #recombination rate
nuvl(0:nx+1,0:ny+1,nisp)    _real  [1/s]  #vol loss rate, ~cs/l_parloss for 1-D
cfvlh			     real         #scal fac for hyd rate in nuvl
cfvli(nisp)		    _real #/nisp*0./#scal fac for individ ion rate nuvl
l_parloss		     real [m] /1.e20/ #parall length for nuvl loss rate
eqp(0:nx+1,0:ny+1)          _real         #equipartition term
eeli(0:nx+1,0:ny+1)         _real  [J]    #electron energy loss per ionization
tdiflim                      real [s] /0./ #lim on hcxe/ne; reduces hcxe if >0
eta1(0:nx+1,0:ny+1)	    _real [J-s/m**3] #Braginskii ion visc coeff eta_1
cfeta1                       real   /0./  # scale factor for eta1
rtaue(0:nx+1,0:ny+1)        _real [s/kg]  #Brag. R coeff (t_e/me)/(w_ce*t_e)**2
cfrtaue			     real   /0./  # scale factor for cfrtaue
dclass_e(0:nx+1,0:ny+1)     _real [m**2/s]#classical elec perp heat conduc.
dclass_i(0:nx+1,0:ny+1)     _real [m**2/s]#classical ion perp heat conduc.
cfcl_e	                     real  /0./   #scale fac for dclass_e
cfcl_i	                     real  /0./   #scale fac for dclass_i
omgci_taui		     real  /10./  #ion gy_freq*coll_rate for cl_model
omgce_taue		     real  /10./  #elec gy_freq*coll_rate for cl_model
nuneo			     real  /0./   #neoclass pol. damping rate; for fqyn

***** Rhsides:
#Variables to evaluate the sources and RHS's.
snic(0:nx+1,0:ny+1,1:nisp)    _real
sniv(0:nx+1,0:ny+1,1:nisp)    _real
psor(0:nx+1,0:ny+1,1:nisp)    _real  [part/s]  # ioniz. source for plasma (>0)
psorxr(0:nx+1,0:ny+1,1:nisp)  _real  [part/s]  # cx &recomb. sink for ions (<0)
psor_tmpov(0:nx+1,0:ny+1)     _real  [part/s]  # work array for psor,etc for ave
psorg(0:nx+1,0:ny+1,1:ngsp)   _real  [part/s]  # ioniz. source for neutral (<0)
psorrg(0:nx+1,0:ny+1,1:ngsp)  _real  [part/s]  # recomb. source for neutrals
psorcxg(0:nx+1,0:ny+1,1:ngsp) _real  [part/s]  # cx source for neutrals 
psori(0:nx+1,0:ny+1,1:nisp)   _real  [part/s]  # impurity gas source
psordis(0:nx+1,0:ny+1)        _real  [part/s]  # diss. source of hydrogen
erliz(0:nx+1,0:ny+1)          _real  [J/s]     # H rad'n loss for ioniz'n
erlrc(0:nx+1,0:ny+1)          _real  [J/s]     # H rad'n loss for recom'n
vsoree(0:nx+1,0:ny+1)	      _real  [J/s]     # combined elec vol eng source
wjdote(0:nx+1,0:ny+1)         _real  [J/s]     # Joule heating rate
smoc(0:nx+1,0:ny+1,1:nusp)    _real
smov(0:nx+1,0:ny+1,1:nusp)    _real
msor(0:nx+1,0:ny+1,1:nisp)    _real [kg-m/s**2]# ioniz. mom. source for ions
msorxr(0:nx+1,0:ny+1,1:nisp)  _real [kg-m/s**2]# cx&recomb. mom. sink for ions 
seec(0:nx+1,0:ny+1)           _real
seev(0:nx+1,0:ny+1)           _real
seic(0:nx+1,0:ny+1)           _real
seiv(0:nx+1,0:ny+1)           _real
resco(0:nx+1,0:ny+1,1:nisp)   _real
resng(0:nx+1,0:ny+1,1:ngsp)   _real
resmo(0:nx+1,0:ny+1,1:nusp)   _real
resee(0:nx+1,0:ny+1)          _real
resei(0:nx+1,0:ny+1)          _real
resphi(0:nx+1,0:ny+1)         _real

***** MCN_dim:
# array bounds used in connection with Monte Carlo Neutrals
nstra		integer		/2/
# number of 'strata' or 'source groups' in Monte-Carlo-Neutrals model;
# i.e., a surface or volume element where neutrals originate;
# for multi-species neutrals, each is a separate source group.
nfl		integer		/1/
# number of plasma fluids recognized by Monte-Carlo-Neutrals model
natmi	integer		/1/
# number of atomic neutral species in EIRENE code
nmoli	integer		/1/
# number of molecular neutral species in EIRENE code
nioni	integer		/1/
# number of molecular ion species in EIRENE code
nxf	integer
# ix dimension from EIRENE file fort.44 or DEGAS2 file testdata.out
nyf	integer
# iy dimension from EIRENE file fort.44 or DEGAS2 file testdata.out
nmcsp	integer		/1/
# number of Monte Carlo species

***** MCN_sources:
# plasma source terms from Monte-Carlo-Neutrals model
ismcnon		integer		/0/
# flag for turning on plasma source terms from Monte-Carlo-Neutrals
# ismcnon=0  --> MCN plasma source terms are OFF (default)
# ismcnon=1  --> MCN-only is used for both Jac'n and RHS in pandf
# ismcnon=2  --> MCN-only is used for RHS, fluid-only is used for Jac'n
ismcnvar	integer		/0/
# flag for scaling plasma source terms from Monte-Carlo-Neutrals
# ismcnvar=0  --> MCN plasma source terms are constant (default)
# ismcnvar=1  --> MCN plasma source terms scale with plate currents
mcnsor_ni(0:nx+1,0:ny+1,1:nisp,1:nstra)	_real	[part/s]
# ion particle source from Monte-Carlo-Neutrals model
mcnsor_up(0:nx+1,0:ny+1,1:nisp,1:nstra)	_real	[kg-m/s**2]
# ion parallel momentum source from Monte-Carlo-Neutrals model
mcnsor_te(0:nx+1,0:ny+1,1:nstra)	_real	[J/s]
# electron thermal energy source from Monte-Carlo-Neutrals model
mcnsor_ti(0:nx+1,0:ny+1,1:nstra)	_real	[J/s]
# ion thermal energy source from Monte-Carlo-Neutrals model
mcncurr(1:nstra)	_real	[part/s]
# neutral source current from each strata in Monte-Carlo-Neutrals model
uesor_ni(0:nx+1,0:ny+1,1:nisp)	_real	[part/s]
# scaled ion particle source from Monte-Carlo-Neutrals model
uesor_up(0:nx+1,0:ny+1,1:nisp)	_real	[kg-m/s**2]
# scaled ion parallel momentum source from Monte-Carlo-Neutrals model
uesor_te(0:nx+1,0:ny+1)		_real	[J/s]
# scaled electron thermal energy source from Monte-Carlo-Neutrals model
uesor_ti(0:nx+1,0:ny+1)		_real	[J/s]
# scaled ion thermal energy source from Monte-Carlo-Neutrals model
uecurr(1:nstra)		_real	[part/s]
# neutral source current from each strata according to UEDGE plasma model
strascal(1:nstra)	_real
# scaling factor for plasma source terms due to each strata
wsor(1:nstra)	_real	[part/s]
# normalization constant for plasma source terms from EIRENE file 'fort.32'
esor(1:nstra)	_real
# unused constant from EIRENE file 'fort.32'
sni(0:nx+1,0:ny+1,1:nfl,1:nstra)	_real	[part/s]
# normalized ion particle sources from EIRENE file 'fort.32'
# or absolute ion particle source from DEGAS2
smo(0:nx+1,0:ny+1,1:nfl,1:nstra)	_real	[kg-m/s**2]
# normalized ion parallel momentum sources from EIRENE file 'fort.32',
# or absolute ion parallel momentum source from DEGAS2
smor(0:nx+1,0:ny+1,1:nfl,1:nstra)	_real	[kg-m/s**2]
# "radial" component of ion momentum source from DEGAS2
smophi(0:nx+1,0:ny+1,1:nfl,1:nstra)	_real	[kg-m/s**2]
# "toroidal" component of ion momentum source from DEGAS2
smoz(0:nx+1,0:ny+1,1:nfl,1:nstra)	_real	[kg-m/s**2]
# "vertical" component of ion momentum source from DEGAS2
see(0:nx+1,0:ny+1,1:nstra)	_real		[J/s]
# normalized electron energy source from EIRENE file 'fort.32'
# or absolute electron energy source from DEGAS2
sei(0:nx+1,0:ny+1,1:nstra)	_real		[J/s]
# normalized ion energy source from EIRENE file 'fort.32'
# or absolute ion energy source from DEGAS2
labela(1:nmcmx)		character*8
# data from Monte Carlo neutrals code:
$ C90 compiler does not allow dynamic character arrays, e.g., labela(1:natmi)
labelm(1:nmcmx)		character*8
# data from Monte Carlo neutrals code:
$ C90 compiler does not allow dynamic character arrays, e.g., labelm(1:nmoli)
labeli(1:nmcmx)		character*8
# data from Monte Carlo neutrals code:
$ C90 compiler does not allow dynamic character arrays, e.g., labeli(1:nioni)
naf(1:nxf,1:nyf,1:natmi)		_real
# data from Monte Carlo neutrals code:
# atomic neutral density
taf(1:nxf,1:nyf,1:natmi)		_real
# data from Monte Carlo neutrals code:
# atomic neutral temperature
nmf(1:nxf,1:nyf,1:nmoli)		_real
# data from Monte Carlo neutrals code:
# molecular neutral density
tmf(1:nxf,1:nyf,1:nmoli)		_real
# data from Monte Carlo neutrals code:
# molecular neutral temperature
ntf(1:nxf,1:nyf,1:nioni)		_real
# data from Monte Carlo neutrals code:
# molecular ion density
ttf(1:nxf,1:nyf,1:nioni)		_real
# data from Monte Carlo neutrals code:
# molecular ion temperature
fnax(1:nxf,1:nyf,1:natmi)	_real
# data from Monte Carlo neutrals code:
# x-particle flux of atomic neutrals
fnmx(1:nxf,1:nyf,1:nmoli)	_real
# data from Monte Carlo neutrals code:
# x-particle flux of molecular neutrals
fntx(1:nxf,1:nyf,1:nioni)	_real
# data from Monte Carlo neutrals code:
# x-particle flux of molecular ions
fnay(1:nxf,1:nyf,1:natmi)	_real
# data from Monte Carlo neutrals code:
# y-particle flux of atomic neutrals
fnmy(1:nxf,1:nyf,1:nmoli)	_real
# data from Monte Carlo neutrals code:
# y-particle flux of molecular neutrals
fnty(1:nxf,1:nyf,1:nioni)	_real
# data from Monte Carlo neutrals code:
# y-particle flux of molecular ions
fnaz(1:nxf,1:nyf,1:natmi)	_real
# data from Monte Carlo neutrals code:
# z-particle flux of atomic neutrals
fnmz(1:nxf,1:nyf,1:nmoli)	_real
# data from Monte Carlo neutrals code:
# z-particle flux of molecular neutrals
fntz(1:nxf,1:nyf,1:nioni)	_real
# data from Monte Carlo neutrals code:
# z-particle flux of molecular ions
feay(1:nxf,1:nyf,1:natmi)	_real
# data from EIRENE file fort.44:  y-energy flux of atomic neutrals
femy(1:nxf,1:nyf,1:nmoli)	_real
# data from EIRENE file fort.44:  y-energy flux of molecular neutrals
feax(1:nxf,1:nyf,1:natmi)	_real
# data from EIRENE file fort.44:  x-energy flux of atomic neutrals
femx(1:nxf,1:nyf,1:nmoli)	_real
# data from EIRENE file fort.44:  x-energy flux of molecular neutrals
hatm(1:nxf,1:nyf)		_real
# data from EIRENE file fort.44:  h-alpha radiation from atomic neutrals
hmol(1:nxf,1:nyf)		_real
# data from EIRENE file fort.44:  h-alpha radiation from molecular neutrals

***** MCN_test:
# densities, temperatures and fluxes from DEGAS2 code
labelmc(1:nmcmx)		character*8
# labels for Monte Carlo species
$ C90 compiler does not allow dynamic character arrays, e.g., labelmc(1:nmcsp)
nmc(1:nxf,1:nyf,1:nmcsp)		_real
# density from Monte Carlo neutrals code
tmc(1:nxf,1:nyf,1:nmcsp)		_real
# temperature from Monte Carlo neutrals code
fnmcx(1:nxf,1:nyf,1:nmcsp)	_real
# x-component of particle flux from Monte Carlo neutrals code
fnmcy(1:nxf,1:nyf,1:nmcsp)	_real
# y-component of particle flux from Monte Carlo neutrals code
fnmcz(1:nxf,1:nyf,1:nmcsp)	_real
# z-component of particle flux from Monte Carlo neutrals code
femcx(1:nxf,1:nyf,1:nmcsp)	_real
# x-component of energy flux from Monte Carlo neutrals code
femcy(1:nxf,1:nyf,1:nmcsp)	_real
# y-component of energy flux from Monte Carlo neutrals code
femcz(1:nxf,1:nyf,1:nmcsp)	_real
# z-component of energy flux from Monte Carlo neutrals code

***** MCN_bkgd:
# plasma background velocities for DEGAS2 Monte-Carlo-Neutrals model
v2c(1:nx,1:ny,1:nisp)	_real	[m/s]
# v2 velocity component at cell centers
vyc(1:nx,1:ny,1:nisp)	_real	[m/s]
# vy velocity component at cell centers
upc(1:nx,1:ny,1:nisp)	_real	[m/s]
# up velocity component at cell centers
uuc(1:nx,1:ny,1:nisp)	_real	[m/s]
# uu velocity component at cell centers
utc(1:nx,1:ny,1:nisp)	_real	[m/s]
# ut velocity component at cell centers
vr(1:nx,1:ny,1:nisp)	_real	[m/s]
# vr velocity component at cell centers
vphi(1:nx,1:ny,1:nisp)	_real	[m/s]
# vphi velocity component at cell centers
vz(1:nx,1:ny,1:nisp)	_real	[m/s]
# vz velocity component at cell centers
v2tg1(1:ny,1:nisp)	_real	[m/s]
# v2 velocity component at target plate number 1 (ix=0)
vytg1(1:ny,1:nisp)	_real	[m/s]
# vy velocity component at target plate number 1 (ix=0)
uptg1(1:ny,1:nisp)	_real	[m/s]
# up velocity component at target plate number 1 (ix=0)
uutg1(1:ny,1:nisp)	_real	[m/s]
# uu velocity component at target plate number 1 (ix=0)
uttg1(1:ny,1:nisp)	_real	[m/s]
# ut velocity component at target plate number 1 (ix=0)
vrtg1(1:ny,1:nisp)	_real	[m/s]
# vr velocity component at target plate number 1 (ix=0)
vphitg1(1:ny,1:nisp)	_real	[m/s]
# vphi velocity component at target plate number 1 (ix=0)
vztg1(1:ny,1:nisp)	_real	[m/s]
# vz velocity component at target plate number 1 (ix=0)
v2tg2(1:ny,1:nisp)	_real	[m/s]
# v2 velocity component at target plate number 2 (ix=nx)
vytg2(1:ny,1:nisp)	_real	[m/s]
# vy velocity component at target plate number 2 (ix=nx)
uptg2(1:ny,1:nisp)	_real	[m/s]
# up velocity component at target plate number 2 (ix=nx)
uutg2(1:ny,1:nisp)	_real	[m/s]
# uu velocity component at target plate number 2 (ix=nx)
uttg2(1:ny,1:nisp)	_real	[m/s]
# ut velocity component at target plate number 2 (ix=nx)
vrtg2(1:ny,1:nisp)	_real	[m/s]
# vr velocity component at target plate number 2 (ix=nx)
vphitg2(1:ny,1:nisp)	_real	[m/s]
# vphi velocity component at target plate number 2 (ix=nx)
vztg2(1:ny,1:nisp)	_real	[m/s]
# vz velocity component at target plate number 2 (ix=nx)

***** Save_terms:
#Arrays to hold unperturbed values of particle-source terms
psorold(1:nisp)		_real	[part/s]  # unpert. ioniz. sources
psorxrold(1:nisp)	_real	[part/s]  # unpert. recom. & cx sources
msorold(1:nisp)		_real	[kg-m/s**2]  # unpert. ioniz. mom. sources
msorxrold(1:nisp)	_real	[kg-m/s**2]  # unpert. recom. & cx mom. sources

***** Time_dep_nwt:
#Old variables and time step for Newton iteration
ylodt(neqmx)  _real              #primary variables for ODE's at last output
nufak          real [1/s] /0./ 	 #pseudo freq. on precond.-Jac diag for nksol
nufak0         real [1/s]   	 #initial value of nufak0 saved (calc)
inufaknk       integer    /1/    #flag for using nufak in Krylov step of nksol
dtreal	       real [s] /1.e20/  #real timestep (both Jac and RHS) for nksol
				 #Do not use large nufak and small dtreal simult
dtreal_old     real [s] /1.e20/  #previous value of dtreal
dtphi	       real [s] /1.e20/  #additional dt to relax phi equation
ydt_max        real              #maximum of yldot*sfscal
ydt_max0       real              #old value of ydt_max
alfnuf         real     /1./     #dtnewt->dtnewt*alfdtn*exp(ydt_max0/ydt_max)
                                 # **expdtn
expnuf         real     /0./     # see alfdtn
deldt          real     /0.3/    # frac. of var. change per cell for var. dt
dtoptx(0:nx+1,0:ny+1) _real      # spatial-depend. time step, min. in a cell
dtoptv(neqmx) _real 	 	 # variable-dependent time step; each var. diff
dtuse(neqmx)  _real 		 # time step used based on model_dt value
model_dt       integer  /0/      # determines dtuse for nksol time-step:
				 #=0, use dtreal
				 #=1, use dtreal*dtoptv/(dtreal+dtoptv)
				 #=2, use dtoptv
				 #=3, use sqrt(dtreal*dtoptv);
				 #=4, use dtreal*dtoptx/(dtreal+dtoptx)
				 #=5, use dtoptx
				 #=6, use sqrt(dtreal*dtoptx)

***** Decomp:
#Arrays required for the L-U decomposition.
ubw                  integer
lbw                  integer

***** Condition_number:
rconds(300,ngrid)	_real	# condition numbers of Jacobians

***** Jacobian:
#Jacobian matrix in compressed sparse row format
neqp1		integer		# Dimension (=neq+1) of jaci
nnzmx		integer		# Maximum no. of nonzeros in Jacobian matrix.
jac(nnzmx)	_real		# Nonzero entries of the Jacobian matrix.
				# This array, together with jacj and jaci,
				# contain the Jacobian in compressed sparse
				# row format.
jaci(neqp1)	_integer	# Nonzero structure of Jacobian matrix jac.
				# jaci(i+1) - jaci(i) = no. of nonzeros
				# in row i of jac.
jacj(nnzmx)	_integer	# Column indices of nonzero entries in jac.

***** Jacobian_csc:
#Jacobian matrix in compressed sparse column format
rcsc(nnzmx)	_real		# Nonzero entries of the Jacobian matrix.
				# This array, together with jcsc and icsc,
				# contain the Jacobian in compressed sparse
				# column format.
jcsc(neq+1)	_integer	# Nonzero structure of Jacobian matrix rcsc.
				# jcsc(j+1) - jcsc(j) = no. of nonzeros
				# in column j of rcsc.
icsc(nnzmx)	_integer	# Row indices of nonzero entries in rcsc.
yldot_pert(neqmx) _real         # Perturbed yldot within Jac_calc (diagnostic)
yldot_unpt(neqmx) _real		# Initial yldot with Jac_calc (diagnostic)

***** Jacobian_part:
#Part of Jacobian matrix arising from a particular equation
nnz1mx		integer		# Length of arrays in Jacobian_part
jac1(nnz1mx)	_real		# Nonzero elements of Jacobian
ia1(nnz1mx)	_integer	# Row indices of elements in jac1, or
				# nonzero structure of jac1 in csr format
ja1(nnz1mx)	_integer	# Column indices of elements in jac1

***** Jacreorder:
#Arrays used in performing a reordering of the rows and columns in the
#Jacobian matrix
perm(neq)	_integer	# Integer array containing the permutation
				# used in reordering the rows and columns of
				# the Jacobian matrix.
qperm(neq)	_integer	# Integer array holding the inverse of the
				# permutation in array perm.
levels(neq)	_integer	# Work array used by the bfs reordering
				# subroutine.   See subroutine bfs for
				# more details.
nlev		integer		# Number of levels in levels array.
				# See subroutine bfs for more details.
mask(neq)	_integer	# Work array used by the bfs reordering
				# subroutine.  See bfs subroutine.
maskval		integer		# Scalar used with mask.
ireorder	integer	    /1/ # Flag used to determine if a reordering
				# of the Jacobian matrix is desired.
				# = 1 means a reverse Cuthill-McKee
				#     reordering of the rows and columns
				#     of the Jacobian is done.
				# = 0 means no reordering.

***** Jacobian_full:
#Jacobian matrix in full storage format
jacfull(neq,neq) _real

***** Preconditioning:
#Parameters for type of preconditioning and sizes of matrices
premeth character*8 /"ilut"/  # type of preconditioning used in the
                              # linear iteration:
                              # ="banded" means use full banded jacobian as
                              #  preconditioner.
                              # ="ilut" means use ilut preconditioning.
                              # ="inel" means use INEL ILU preconditioning
lenpfac        integer   /60/ # fudge factor to multiply neq by to get an
                              # estimate for the number of nonzeros in the
                              # preconditioner matrix.
lenplufac      integer  /100/ # fudge factor to multiply neq by to get an
                              # estimate for the number of nonzeros in the
                              # factored preconditioner matrix.
lenplumx       integer        # maximum number of nonzeros in the
                              # factored preconditioner matrix
                              # lenplumx = nnzmx + lenplufac*neq.
***** Ilutv:
#Control parameters for ILUT preconditioner
tolilut        real   /1.e-3/ # threshold tolerance for ILUT.
lfililut       integer   /50/ # fill-in parameter used in ILUT.  ILUT
                              # will allow up to lfililut additional nonzeros
                              # in each row of L and U.

***** Nonzero_diagonals:
ndiagmx        integer  /100/ # maximum number of nonzero diagonals in the
                              # Jacobian matrix
ndiag          integer        # actual number of nonzero diagonals in the
                              # Jacobian matrix
lfilinel       integer   /0/  # fill-in parameter used in INEL preconditioner
                              # lfilinel= number of additional diagonals
                              # used in the INEL ILU preconditioner
                              # lfilinel+ndiag .le. ndiagmx.
ndiagm         integer        # number of nonzero diagonals stored in the
                              # INEL ILU preconditioner
                              # = min(lfilinel+ndiag,ndiagmx)
adiag(neq,ndiagmx) _real      # diagonals of the Jacobian matrix
siginel(neq)   _real          # work array used by INEL precond5
fmuinel(neq)   _real          # work array used by INEL precond5
rwkd(ndiagmx)  _real          # work array used by cdiagsrt
iwkd1(2*neq-1) _integer       # number of nonzeros in each diagonal
iwkd2(ndiagmx) _integer       # work array used by cdiagsrt

***** UEint:
#Auxiliary variables for Ueinit.
newgeo         integer   /1/  #flag to calculate new grid (1=yes)
mhdgeo         integer  /-1/  #flag for grid geometry
                              #mhdgeo =  2 ==> toroidal circular limiter
                              #mhdgeo =  1 ==> toroidal MHD equilibrium
                              #mhdgeo =  0 ==> cylindrical geometry
                              #mhdgeo = -1 ==> cartesian geometry
gengrid        integer   /1/  #flag to generate grid, else read from file gridue
isgindx        integer   /1/  #=1 for interpolating grid based on indices
nfmax          integer   /10/
restart        integer   /0/  #flag for restart from previous case(yes=1)
initsol        integer   /0/  #flag to initially solve algebraic eqns for
                              #DASPK (yes=1)
ttbeg          real                  #initial Te in Joules = tinit/ev (calc)
tinit          real      /40./       #initial electron temperature Te in eV
tscal          real      /.5/        #ratio of initial Ti to Te
ngscal(ngspmx) real   /ngspmx*.1/    #ratio of initial gas density to ion dens
xgscal         real      /1./        #exponential scale of initial gas (m) 
nibeg(1:nispmx) real  /nispmx*2.e19/ #initial ion density
minu(1:nispmx)  real  /nispmx*2./    #ion mass in units of proton mass (AMU)
ziin(1:nispmx)  real  /nispmx*1./    #ion charge read in, used to reset zi in
                                     #group Compla which gets erased on gallot
znuclin(1:nispmx) integer /nispmx*1./ #total nuclear charge of ion (i.d. isotope)
isallloc		integer   /0/        #=1 for local process. allocation with mpi
newaph			integer  /1/ #=1 calls aphread for hyd. atomic data;=0 not
newapi		integer /1/	     #=1, call readmc for new imp. data;=0, no						  
***** Interp:
#Variables for the interpolation
isnintp                      integer /1/ +restart
                                       #switch to turn on new interpol. (=1)
                                       #also check isgindx switch in UEint
isimesh                      integer /1/ #flag for initial mesh => must copy
                                         #save variables and not interpolate
isumesh2		     integer /0/ #for parallel vers;=1, interp new mesh
nxold                        integer
nyold                        integer
nxoldg                       integer
nyoldg                       integer
ixlbo(1:nxpt)                _integer  #prev. grid value for ixlb
ixpt1o(1:nxpt)               _integer  #prev. grid value for ixpt1
ixpt2o(1:nxpt)               _integer  #prev. grid value for ixpt2
ixrbo(1:nxpt)                _integer  #prev. grid value for ixrb
iysptrxo                     integer   #prev. grid value for iysptrx
xnrmo(0:nxold+1,0:nyold+1)   _real     #norm. x-grd; old x-grid, old y-grid
xvnrmo(0:nxold+1,0:nyold+1)  _real     #norm. xv-grd; old x-grid, old y-grid
xnrmox(0:nxold+1,0:ny+1)     _real     #norm. x-grd;nxold grd interp. to new ny
xvnrmox(0:nxold+1,0:ny+1)    _real     #norm. xv-grd;nxold grd interp.to new ny
xnrmnx(0:nx+1,0:ny+1)        _real     #norm. x-grd; second intermed. grid
xvnrmnx(0:nx+1,0:ny+1)       _real     #norm. xv-grd; second intermed. grid
ynrmo(0:nxold+1,0:nyold+1)   _real     #norm. y-grd; old x-grid, old y-grid
yvnrmo(0:nxold+1,0:nyold+1)  _real     #norm. yv-grd; old x-grid, old y-grid
ynrmox(0:nxold+1,0:ny+1)     _real     #norm. y-grd; old x-grid, new y-grid
yvnrmox(0:nxold+1,0:ny+1)    _real     #norm. yv-grd; old xv-grid, new y-grid
ynrmnx(0:nx+1,0:ny+1)        _real     #norm. y-grd; second intermed. grid
yvnrmnx(0:nx+1,0:ny+1)       _real     #norm. yv-grd; second intermed. grid
wrkint(0:nxold+1,0:ny+1)     _real     #wrk array; vars on old x, new y grid
wrkint2(0:nx+1,0:ny+1)       _real     #wrk array; vars on second interm. grid
ixmg(0:nxold+1,0:ny+1)       _integer  #ix index used for (ixo,iy) pt.
iyomg(0:nxold+1,0:ny+1)      _integer  #iyo index used for (ixo,iy) pt.
ixvmg(0:nxold+1,0:ny+1)      _integer  #ixv index used for (ixvo,iy) pt.
iyvomg(0:nxold+1,0:ny+1)     _integer  #iyvo index used for (ixvo,iy) pt.
ix2g(0:nx+1,0:ny+1)          _integer  #ix index for sec. interm. (ix,iy) pt.
iy2g(0:nx+1,0:ny+1)          _integer  #iy index for sec. interm. (ixo,iy) pt.
ixv2g(0:nx+1,0:ny+1)         _integer  #ixv index for sec. interm.(ixvo,iy) pt.
iyv2g(0:nx+1,0:ny+1)         _integer  #iyv index for sec.interm.(ixvo,iy) pt.
nis(0:nxold+1,0:nyold+1,1:nisp) _real [m^-3] +restart
                                             #ion dens at last success. calc
tes(0:nxold+1,0:nyold+1)        _real [J]    +restart
                                             #elec. temp at last success. calc
tis(0:nxold+1,0:nyold+1)        _real [J]    +restart
                                             #ion temp at last success. calc
phis(0:nxold+1,0:nyold+1)       _real [V]    +restart
                                             #potential at last success. calc
ups(0:nxold+1,0:nyold+1,1:nisp) _real [m/s]  +restart
                                             #parall. vel at last success. calc
ngs(0:nxold+1,0:nyold+1,1:ngsp) _real [m^-3] +restart
                                             #gas dens at last success. calc.
afracs(0:nxold+1,0:nyold+1)     _real [ ]    +restart
					     #rel. imp. frac at last succ. calc

***** Global_vars:
# Arrays for primary variables over full mesh for domain decomposition
nisg(0:nxoldg+1,0:nyoldg+1,1:nisp) _real [m^-3] #global array for nis
tesg(0:nxoldg+1,0:nyoldg+1)        _real [J]    #global array for tes
tisg(0:nxoldg+1,0:nyoldg+1)        _real [J]    #global array for tis
phisg(0:nxoldg+1,0:nyoldg+1)       _real [V]    #global array for phis
upsg(0:nxoldg+1,0:nyoldg+1,1:nisp) _real [m/s]  #global array for ups
ngsg(0:nxoldg+1,0:nyoldg+1,1:ngsp) _real [m^-3] #global array for ngs
afracsg(0:nxoldg+1,0:nyoldg+1)     _real [ ]    #global array for afracs

***** Global_input:
# Arrays for real and integer input variables to be passed for domain decomp.
ipassin(1:100)		integer 	#integer input variables to be passed
rpassin(1:100)		real 		#real input variables to be passed
cpassin(1:30)		character*8 	#character input variables to be passed

***** Npes_mpi:
# Processor numbers for parallel version with mpi
npes		integer		#total number of processors
mype		integer		#processor number of local processor (domain)
ismpion	        integer /0/     #flag to indicate using MPI (if=1)

***** Indices_domain_dcg:
# Indices used for domain decomposition on the global mesh
isddcon		  integer   /0/	   #switch to turn on domain decomposition 
ndleg(1:10,1:2)   integer   /20*1/ #number of x-domains in nxleg regions
ndxcore(1:10)     integer   /10*1/ #number of x-domains in nxcore(,1:2) regions
ndycore(1:10)     integer   /10*1/ #number of y-domains in core
ndysol(1:10)      integer   /10*1/ #number of y-domains in sol
ndxt              integer          #total number of x-domains
ndyt              integer          #total number of y-domains
ndomain           integer   /1/    #total number of domains
nvrsend           integer /10000/  #size of global real send/recv array for MPI
nvisend 	  integer /10000/  #size of global integer send/recv array for MPI
ixmin(ndomainmx)	integer    #min global ix for given domain 
ixmax(ndomainmx)	integer    #max global ix for given domain 
iymin(ndomainmx)	integer    #min global iy for given domain 
iymax(ndomainmx)	integer    #max global iy for given domain 
ixmnbcg(ndomainmx)	integer /ndomainmx*1/
                               	#B.C. type at ix=ixmin bdry;=0 inter.,=1 ex.
ixmxbcg(ndomainmx)	integer /ndomainmx*1/
			       	#B.C. type at ix=ixmax bdry;=0 inter.,=1 ex.
iymnbcg(ndomainmx)	integer /ndomainmx*1/
				#B.C. type at iy=iymin bdry;=0 inter.,=1 ex.
iymxbcg(ndomainmx)	integer /ndomainmx*1/
				#B.C. type at iy=iymax bdry;=0 inter.,=1 ex.
ncell(ndomainmx)	integer    #number of cells for given domain
idxp1g(ndomainmx)	integer    #domain to the right of given domain (ix+1)
idxm1g(ndomainmx)	integer    #domain to the left of given domain (ix-1)
idyp1g(ndomainmx)	integer    #domain above given domain (iy+1)
idym1g(ndomainmx)	integer    #domain below given domain (iy-1)
idcorng(ndomainmx,1:4)	integer    #domains touching corners; from lower left,
				   #numbering counterclockwise (1,2,4,3)
ixpt1g(ndomainmx)	integer    #ixpt1 for a given domain
ixpt2g(ndomainmx)	integer    #ixpt2 for a given domain
iysptrxg(ndomainmx)	integer    #iysptrx for a given domain
vrsend(nvrsend)        _real	   #real array used for passing global data via MPI
visend(nvisend)        _integer	   #int array used for passing global data via MPI

***** Indices_domain_dcl:
# Indices used to connect a given domain with "neighbors"; known on local processor
nx_loc		integer		#number of ix cells for given processor
ny_loc		integer		#number of iy cells for given processor
nvrsendl	integer	/10000/	#size of local real send/recv array for MPI
nvisendl	integer	/10000/	#size of local integer send/recv array for MPI
ixmnbcl		integer   /1/   #B.C. type at ix=ixmin bdry;=0 inter.,=1 ex.
ixmxbcl		integer   /1/   #B.C. type at ix=ixmax bdry;=0 inter.,=1 ex.
iymnbcl		integer   /1/   #B.C. type at ix=iymin bdry;=0 inter.,=1 ex.
iymxbcl		integer   /1/   #B.C. type at iy=iymax bdry;=0 inter.,=1 ex.
idxp1		integer   	#domain to the right of given domain (ix+1)
idxm1		integer 	#domain to the left of given domain (ix-1)
idyp1		integer 	#domain to the above given domain (iy+1)
idym1		integer 	#domain to the below given domain (iy-1)
idcorn(1:4)	integer		#domains touching corners; from lower left,
				#numbering counterclockwise (1,2,4,3)
iv_totbdy(1:8)  integer  /8*0/  #number of elems. in bdry messages vrsendl
typebdyi(1:4)   integer /21,22,23,24/ #mpi tags for bdry iv_totbdy along edges
typecni(1:4)    integer /25,26,27,28/ #mpi tags for bdry iv_totbdy at corners
typebdy(1:4)    integer /11,12,13,14/ #mpi tags for bdry vrsendl along edges
typecn(1:4)     integer /15,16,17,18/ #mpi tags for bdry vrsendl at corners
vrsendl(nvrsendl) _real	        #real array used for passing local data via MPI
visendl(nvisendl) _integer      #int array used for passing local data via MPI

***** Jacaux:
#Internal variables of jacnw
scrit             real            /1.e-4/
ylold(neqmx)     _real
yldot1(neqmx)    _real
yldot0(neqmx)    _real
normtype          integer /0/  #0,1,2 for max-norm, 1-norm, or 2-norm row scaling
fnormnw(neqmx)   _real
issfon            integer /1/  #=1 calc sfscal for row scaling (norml.) by nksol
isrnorm           integer /1/  #=1 causes row normaliza. of Jac. (see normtype)
jscalcol          integer /0/  #=1 causes column scaling for daspk

***** Variable_perturbation restart:
del             real	/1.e-7/		# fractional change for finite diffs
dylconst        real    /1./            # factor in floor term in dyl
isjacreset      integer  /1/            # if=1, pandf1 reset for last variable

***** Jacobian_clipping restart:
jaccliplim	real	  /0./	# rel. value of elements to be retained
istopjac        integer   /0/   # flag to stop if non-zero elem at irstop,icstop
irstop          integer   /0/   # row (or eqn) index of non-zero stopping test
icstop          integer   /0/   # column (or var.) index of n-z stopping test

***** Newtaux:
icsum              integer
rwmin              real    /1.e-7/ #value of sumnew1 to stop Newton iter.
saux               real
saux1              real
sumnew             real
sumrdy             real
nmaxnewt           integer /15/    #max number of Newton iterations
ysave(2,neqmx)    _real            #last two yl's in Newton (1,) most recent    
ycor(neqmx)       _real
saux2(nmaxnewt)    _real           #maximum update allowed in Newton
sumf(0:nmaxnewt)   _real           #ave value of right-hand-sides after Newton
irwd(nmaxnewt,2)   _integer
rwdmax(nmaxnewt,2) _real
rwdmin(nmaxnewt,2) _real
sumnew1(nmaxnewt)  _real           #average change in variables for Newton iter.
sumr1dy(nmaxnewt)  _real

***** Cdv:
#Commonly defined variables
ifexmain           integer /0/  #scalar to indicate if subroutine allocate
                                #is called by exmain.
                                #=1 means allocate is called by exmain,
                                #=0 means it is not.
iallcall	   integer /0/  #flag to signal first call to allocate

***** RZ_cell_info:
# RZ grid-cell center and face locations
rcn(0:nxm+1,0:nym+1)        _real [m]    # radial position of density cell
zcn(0:nxm+1,0:nym+1)        _real [m]    # vertical position of density cell
rfn(-1:nxm+1,-1:nym+1)      _real [m]    # radial position of density face
zfn(-1:nxm+1,-1:nym+1)      _real [m]    # vertical position of density face
rcv(0:nxm+1,0:nym+1)        _real [m]    # radial position of velocity cell
zcv(0:nxm+1,0:nym+1)        _real [m]    # vertical position of velocity cell
rfv(0:nxm+2,0:nym+2)        _real [m]    # radial position of velocity face
zfv(0:nxm+2,0:nym+2)        _real [m]    # vertical position of velocity face

***** Subs:
# Subroutines that can be called from the BASIS parser
#
exmain                                           subroutine
exmain_prelims                                   subroutine
uedriv()                                         subroutine
convert()                                        subroutine
convsr_vo(i,j,yl:real)                           subroutine
convsr_aux(i,j,yl:real)                          subroutine
pandf(i,j,neq:integer,t:real,yl:real,yldot:real) subroutine
pandf1(i,j,ieq,neq:integer,t:real,yl:real,\
       yldot:real) 				 subroutine
bouncon(neq:integer,yl:real,yldot:real)          subroutine
poteneq(i,a:real,b:real)                         subroutine
ffun(neq:integer,t:real,yl:real,yldot:real)      subroutine
resid(t:real,y:real,yp:real,delta:real,ires,\
      rp:real,ip)                  		 subroutine
ueinit()                                         subroutine
gridseq()                                        subroutine
nphygeo()                                        subroutine
jacnw(neq,yl:real,f0:real,dt:real,wk:real,\
      wp:real,iwp)                   		 subroutine
  # calc LU of Jacobian at yl
psolnw(neq,yl:real,wk:real,wp:real,iwp,\
       bl:real,ierr)                		 subroutine
psolbody(neq,using:logical,suscal:real,wk:real,\
       wp:real,iwp,bl:real,ierr) 		 subroutine
csrcsc(neq,job,ipos,rcsc:real,icsc,jcsc,\
       jac:real,jacj,jaci)                       subroutine
  # Note that csrcsc resides in uedge/svr/svrut4.f
allocate()                                	 subroutine
walsor()                                  	 subroutine
volsor()                                  	 subroutine
write_profs()                                  	 subroutine
read_profs()                                  	 subroutine
write_profs_boris(fname:string)		      	 subroutine
read_profs_boris(fname:string,ierr)		       	 subroutine
quadsvr(neq,a:real,b:real,c:real,d:real,yl:real,\
        yldot:real,ylprev:real,ylchng:real,\
        sfscal:real)         			 subroutine
  # actual args are (neq,xs,xs1,xs2,xs3,ys1,ys2,ys3,yq1,yq2)
aplsb(nrow,ncol,a:real,ja,ia,s:real,b:real,\
      jb,ib,c:real,jc,ic,nzmax,iw,ierr)   	 subroutine
  # Calculate C = A+s*B, where A, B, and C are matrices in
  # compressed sparse row format (e.g., A is in a,ja,ia).
  # Dimensions for output and work arrays:  c(nnzmx),jc(nnzmx),
  # ic(nrow+1),iw(ncol).  ierr=0 if nnzmx was large enough.
jacmap()                                  	 subroutine
  # output Jacobian map to file
jacout()                                  	 subroutine
      # output Jacobian matrix in Boeing-Harwell format to a file
radintp(i,j,k,l,m,n,ii,jj,kk,ll,a:real,b:real,\
        c:real,d:real) 				 subroutine
      # does interpolation in radial direction
polintp(i,j,k,l,m,n,ii,jj,kk,ll,a:real,b:real,\
        c:real,d:real) 				 subroutine
      # does interpolation in poloidal direction
intpvar(a:real,b:real,i,j,k,l,m,n,ii,jj,\
        geom:string)	 			 subroutine
      # does combined radial and poloidal interpolation
engbal(a:real)                                 	 subroutine
      # calc. arrays for postproc. energy balance
pradplt()                                        subroutine
      # calc. radiation flux on plates from impurities and hydrogen
pradpltwl()                                      subroutine
      # calc. radiation flux on plates from impurities and hydrogen
plateflux()					 subroutine
      # calc. particle and energy fluxes to plates
wallflux()          				 subroutine
      # calc. particle and energy fluxes to outer wall
ebindz(za:integer, zn:integer)                   real function
      # calculates the ionization energy for atomic charge state za-->za+1
      # of impurity with total nuclear charge zn.
wtottim()					 subroutine
      # writes out timing information
domain_dc()					 subroutine
      # calculates indices of domains for domain decomposition
bbb2wdf()                                        subroutine
      # write file containing plasma information for DEGAS namelist
write30 (fname:string, runid:string)		subroutine
      # write geometry data file 'fname' for EIRENE code
write31 (fname:string, runid:string)		subroutine
      # write plasma data file 'fname' for EIRENE code
write_eirene					subroutine
      # write geometry and plasma data files for EIRENE code
read32 (fname:string)		subroutine
      # read source term data file fname='fort.32' from EIRENE code
read44 (fname:string)		subroutine
      # read diagnostic data file fname='fort.44' from EIRENE code
writemcnfile (fname:string, runid:string)		subroutine
      # write geometry and plasma background data for DEGAS2 code
readmcntest (fname:string)	subroutine
      # read neutral density, temperature and flux data from DEGAS2 code
readmcnsor (fname:string)	subroutine
      # read plasma source data from DEGAS2 code
lmode_roots(bcoef:complex, ccoef:complex, omega:complex)   subroutine
lmode_chi_norm(kappabar:real, lte:real, rhos:real,
   cubrtnu:real, ti0:real, ted:real, zavg:real,
   lpi:real, lambdap:real,
   maxmag:real, nky:integer, kybeg:real, kyend:real, kya:real, kyb:real,
   tol:real, iprint:integer, islmodebeta:integer, kt:real,
   lmodechin:real, gammamax:real, kymax:real)   subroutine
hmode_chi_norm (gradvconst:real, cubrtnu:real, epsilon:real, lambdap:real,
   hmodechin:real)   subroutine
turb_chi (lmodechin:real, hmodechin:real, rhos:real, csed:real, lte:real,
   lambdap:real, cubrtnu:real, chi:real)   subroutine
read_zag()				   subroutine
     # reads output for Zagorski's edge code
kappa (fqpsati:real, fqpsate:real, fqp:real)	real function
     # Calculates sheath drop (in units of Te) with modified form 
     # that allows fqp > fqpsati and fqpsati < 0.
     # Adjustable form factors are kappamx and kappa0
mombal(ix:integer, ix1:integer, iy:integer)     subroutine
     # calculates impurity upi and frici from Hirschman's fmombal
     # ix1=ixp1(ix,iy)
mombalni(ix:integer, ix1:integer, iy:integer)   subroutine
     # calculates impurity upi and frici from force balance
     # ix1=ixp1(ix,iy)

***** Imprad:
# variables associated with impurity radiation
isimpon                 integer   /0/ +restart
                               # switch for impurity model:
                               # 0 for no impurities
                               # 2 for fixed-fraction model
                               # 3 for average-impurity-ion model(disabled)
                               # 4 for INEL multi-charge-state model(disabled)
                               # 5 for Hirshman's reduced-ion model
                               # 6 for force-balance model
nusp_imp        integer  /0/   # fixes nusp for total num. of par. mom. eqns.
isupimpap       integer  /1/   # =1 includes imp atm phys in up eqn; =0, omits
ismctab		integer		/1/	+restart
# Determines which data is used for multi-charge-state rates.
#	=1  tables originally generated by R. Campbell for D. Knoll,
#	    data file name is specified by inelmc=....
#	    corresponding rate evaluation routines are imprates and radimpmc.
#	=2  tables generated by code from B. Braams,
#	    data file name is specified by mcfilename=...,
#	    corresponding rate evaluation routines are mcrates and radmc.
nzloc(0:nzspmx)		_real	[/m**3]
                               # imp. dens. for each Z at one grid cell
impradloc(0:nzspmx)	_real	[Watts/m**3]
                  # rad. power loss density for each Z at one grid cell
pwrze(0:nx+1,0:ny+1)	_real	[Watts/m**3]
                               # electron energy loss due to impurities
prad(0:nx+1,0:ny+1)	_real	[Watts/m**3]
                               # total impurity radiation
pradz(0:nx+1,0:ny+1,0:nzspmx,1:ngsp-1)	_real	[Watts/m**3]
                               # impurity radiation due to each imp. ch. state
na(0:nx+1,0:ny+1)	_real	[/m**3]
                               # atomic density of impurity (=afrac*ne)
ntau(0:nx+1,0:ny+1)	_real	[sec/m**3]
                               # confinement parameter for impurity (=atau*ne)
nratio(0:nx+1,0:ny+1)	_real 
                               # ratio of neutrals to electrons
afrac(0:nx+1,0:ny+1)	_real	/.00/ +restart
                               # atomic concentration of impurity
atau(0:nx+1,0:ny+1)	_real	/1./	[sec] +restart
                               # lifetime of impurity
tau1(0:nx+1,0:ny+1)	_real	# time to escape to inboard divertor plate
tau2(0:nx+1,0:ny+1)	_real	# time to escape to outboard divertor plate

***** Impurity_source_flux:
# Arrays for impurity-source fluxes calculated from api variables
fnzysi(0:nx+1,nzspt)	_real	# profiles along inner wall
fnzyso(0:nx+1,nzspt)	_real	# profiles along outer wall

***** Reduced_ion_interface:
# Arrays for info transfer between subroutines mombal and fmombal
misotope		integer  # number of isotopes (including electrons)
nchstate		integer  # maximum charge state among all isotopes
natomic(1:MXMISO)	integer  # maximum charge state of each isotope
amu(1:misotope)		_real	[none]     # atomic mass, relative to proton
tempa(1:misotope)	_real	[J]        # temperature
qneut(1:misotope)	_real	[J/m**2-s] # parallel heat flux of neutral
uneut(1:misotope)	_real	[m/s]      # parallel flow speed of neutral
den(1:misotope,0:nchstate)	_real	[1/m**3] # density
gradp(1:misotope,1:nchstate)	_real	[J/m**4] # parallel pressure grad
gradt(1:misotope,1:nchstate)	_real	[J/m**4] # parallel temp gradient
friction(1:misotope,1:nchstate)	_real	[J/m**4] # parallel friction force
nuion(1:misotope,0:nchstate)	_real	[1/s]    # ionization rate
nurec(1:misotope,1:nchstate)	_real	[1/s]    # recombination rate
qcond(1:misotope,1:nchstate)	_real	[J/m**2-s] # parallel heat flux
ucond(1:misotope,1:nchstate)	_real	[m/s]      # parallel flow speed

***** Solver_work_arrays:
# Work arrays used to communicate with solver routines
liw			integer	  /1/	# length of iwork
lrw			integer	  /1/	# length of rwork
iwork(liw)		_integer	# integer work array
rwork(lrw)		_real		# real work array 

***** Jac_work_arrays:
# work arrays needed by Jac routines when using cvode (FPRECO)
liwp			integer   /1/	# length of iwwp
lwp			integer	  /1/	# length of wwp
iwwp(liwp)	       _integer		# integer work array 
wwp(lwp)	       _real		# real work array

***** Temporary_work_arrays:
rwk1(neq+1)		_real
rwk2(neq+1)		_real
iwk1(neq+1)		_integer
iwk2(neq+1)		_integer
iwk3(neq+1)		_integer

***** Zag_output:
# Arrays used to store output from Zagorski's FPIT edge code
# PLASMA common block
nezag(imx+1,imy+1)	_real	# Zagorski's electron density
nizag(imx+1,imy+1)	_real	# Zagorski's hydrogen ion density
tezag(imx+1,imy+1)	_real	# Zagorski's electron temperature
tizag(imx+1,imy+1)	_real	# Zagorski's electron temperature
vizag(imx+1,imy+1)	_real	# Zagorski's velocity 1
uizag(imx+1,imy+1)	_real	# Zagorski's velocity 2
v0zag(imx+1,imy+1,5) 	_real	# Zagorski's velocity 3
u0zag(imx+1,imy+1,5) 	_real	# Zagorski's velocity 4
zeffzag(imx+1,imy+1)	_real	# Zagorski's Zeff
elfzag(imx+1,imy+1)	_real	# Zagorski's elf
vezag(imx+1,imy+1)	_real	# Zagorski's ve
uezag(imx+1,imy+1)	_real	# Zagorski's ue
curxzag(imx+1,imy+1)	_real	# Zagorski's curx
curyzag(imx+1,imy+1)	_real	# Zagorski's cury
t0zag(imx+1,imy+1,5) 	_real	# Zagorski's t0
n0zag(imx+1,imy+1,5) 	_real	# Zagorski's n0
tz0zag(imx+1,imy+1) 	_real	# Zagorski's tz0
# IMPUR common block
nzzag(imx+1,imy+1,lnst+1) _real	# Zagorski's nz
vzzag(imx+1,imy+1,lnst+1) _real	# Zagorski's vz
uzzag(imx+1,imy+1,lnst+1) _real	# Zagorski's uz
# GEOMETRY common block
rxzag(imx+1,imy+1)	_real	# Zagorski's rx
ryzag(imx+1,imy+1)	_real	# Zagorski's ry
ggzag(imx+1,imy+1)	_real	# Zagorski's gg
bratiozag(imx+1,imy+1)	_real	# Zagorski's bratio
viparzag(imx+1,imy+1)	_real	# Zagorski's vipar
veparzag(imx+1,imy+1)	_real	# Zagorski's vepar
vzparzag(imx+1,imy+1,lnst+1) _real # Zagorski's vzpar
# NET common block
xpzag		 	 real   # Zagorski's xp
xszag			 real	# Zagorski's xs
xkzag			 real	# Zagorski's xk
ypzag			 real	# Zagorski's yp
ykzag			 real	# Zagorski's yk
xzag(imx+2)		_real	# Zagorski's x
yzag(imy+2)		_real	# Zagorski's y
# WARIANT common block
inh			integer
inz		/0/	integer
ihf			integer
istype			integer
ibound			integer
iboundz			integer
zs			real
spuff			real
# PARAM common block
lst			integer
wx			real
wy			real
ht			real
rmach			real
recyc			real
zrecyc			real
imap			integer
snz			real
sn			real
sqe			real
sqi			real
fe(imx+1)	       _real
fi(imx+1)	       _real
fe0			real
fi0			real
flime			real
flimi			real
wkr			real
# OUT common block
xsi			real
zxsi			real
sdod(imx+1,imy+1,lnst+1) _real
yielh(imx+1)	       _real
yielz(imx+1,lnst+1)    _real

***** Ident_vars:
uedge_ver character*80 /'$Name:  $'/
uedge_date character*80 /'Version date in README_Uedge_vers in dir uedge'/

***** Last_group_ex_sav_var:
# Last group in bbb where new variables from read save files get stored


                      Package api

                      Physical_constants2
                      ------------------------

            Add the 2 to distinquish from same constants in package bbb
                      ------------------------
ev2 
ev2   1 electron volt in Joules
qe2 
qe2   elementary charge in Coulombs

                      Normalization_constants
                      ------------------------

            Constants set within subroutine inelinput and used in some impurity
            routines to convert to MKS units
                      ------------------------
crni 
crni   multiplicative constant to convert densities to MKS
ctemp 
ctemp   multiplicative constant to convert temperatures to MKS

                      Impfcn
                      ------------------------

            routines for computing quantities relevant to impurity radiation
                      ------------------------
getatau (nx,ny,uu,gx,ixpt1,ixpt2,iysptrx,atau,tau1,tau2)
getatau   computes ion/impurity lifetime for pol. flow along flux surfaces,
getatau   evaluates arrays atau, tau1, and tau2
getprad (nx,ny,ngsp,te,ne:real,ng:real,afrac,atau,prad,na:real,ntau:real,nratio:real)
getprad   computes the impurity radiation loss for electrons,
getprad   evaluates arrays prad, na, ntau, and nratio

                      Impurity_transport
                      ------------------------

            variable specifying radial transport rate of impurities
                      ------------------------
dnimp 
methimp 
methimp   specifies interp. for finite diff. for (y,x)
methimp   66 is log interp., 77 inverse interp.,
methimp   otherwise linear interp.
csexpn 
csexpn   exponent for reducing impurity || vel from
csexpn   being too supersonic (1+x**(4-csexpn))/(1+x**4)
csexpn   with x=v||/cs; range should be 0->1, with 0.3 

                      Impurity_source
                      ------------------------

            array for impurity source
                      ------------------------
simpfix (nx,ny)
simpfix   vol. source (avg-ion or Z=1) input by user

                      Sources_at_walls
                      ------------------------

            arrays for impurity sources on inner and outer walls
                      ------------------------
nzsor 
nzsor   number of impurity sources
iszsorlb (nzspt,nzsor)
iszsorlb   =1 if origin of ximp* is at left bndry
jxzsori (nzspt,nzsor)
jxzsori   ximpi=0. is located at left boundary
jxzsori   of mesh region jxzsori for iszsorlb=1
jxzsoro (nzspt,nzsor)
jxzsoro   ximpo=0. is located at left boundary
jxzsoro   of mesh region jxzsori for iszsorlb=1
ixzbegi (nzspt,nzsor)
ixzbegi   ximpi=0. is located at cell index 
ixzbegi   ix=ixzbegi for iszsorlb=1
ixzendi (nzspt,nzsor)
ixzendi   ximpi=0. is located at cell index 
ixzendi   ix=ixzendi for iszsorlb=0
ixzbego (nzspt,nzsor)
ixzbego   ximpo=0. is located at cell index 
ixzbego   ix=ixzbego for iszsorlb=1
ixzendo (nzspt,nzsor)
ixzendo   ximpo=0. is located at cell index 
ixzendo   ix=ixzendo for iszsorlb=0
ximpi (nzspt,nzsor)
ximpi   center of source profile (inner wall)
ximpo (nzspt,nzsor)
ximpo   center of source profile (outer wall)
wimpi (nzspt,nzsor)
wimpi   width of source profile (inner wall)
wimpo (nzspt,nzsor)
wimpo   width of source profile (outer wall)
impsori (nzspt,nzsor)
impsori   impurity source strength (inner wall)
impsoro (nzspt,nzsor)
impsoro   impurity source strength (outer wall)

                      Input
                      ------------------------

            variables for input file names
                      ------------------------
inelrates (1)
inelrates   (1) needed for pymac
inelrad (1)
inelmc (1)

                      Radiation
                      ------------------------

            dimension variables and arrays for radiation
            read by namelist so cannot be allocated dynamically
                      ------------------------
ncaset 
ncaseno 
ncasent 
terad (NCASET)
xno (NCASENO)
rntau (NCASENT)
radrate (NCASET,NCASENO,NCASENT)
avgz (NCASET,NCASENO,NCASENT)
avgz2 (NCASET,NCASENO,NCASENT)

                      MC_subs
                      ------------------------

                      ------------------------
readmc (nzdf,mcfilename)
readmc   reads formatted data tables for one or more impurities from files
readmc   specified by mcfilename(1:nzdf) (default filename is 'b2frates')
mcrates (ne:real,te,ti,\za:integer,zamax:integer,zn:integer,rion,rrec,rcxr)
mcrates   computes rate parameters for impurity transitions that originate
mcrates   from atomic charge state za of the impurity with nuclear charge zn,
mcrates   where the maximum atomic charge state is zamax.
radmc (nz:integer,znuc:integer,te,dene,denz,radz)
radmc   computes the radiation rates radz(0:nz) in [W/m**3] for various
radmc   charge states of an impurity with nuclear charge znuc;
radmc   this function returns the total electron energy loss rate in [W/m**3]
rcxr_zn6 (tmp,za:integer)
rcxr_zn6   compute cx rate for carbon ions on neutral hydrogen using
rcxr_zn6   polynomial fit to curves in thesis by C.F. Maggi (1997).
rcxr_zn6   input neutral hydrogen temperature, tmp, is in Joules/AMU;
rcxr_zn6   za is initial carbon ion charge;
rcxr_zn6   output is <sigma*v> in m**3/sec.

                      Impurity_charge
                      ------------------------

                      ------------------------
nnz 
zq (nnz)

                      P93dat
                      ------------------------

            variables associated with impurity radiation from Post '93 tables
                      ------------------------
atn 
atn   atomic number
atw 
atw   atomic weight
nt 
nt   number of temperature values
nr 
nr   number of density ratio values
nn 
nn   number of n*tau values
tdatm (nt,nr,nn)
tdatm   temperature
rdatm (nt,nr,nn)
rdatm   density ratio
ndatm (nt,nr,nn)
ndatm   n*tau
emdatm (nt,nr,nn)
emdatm   emissivity
z1datm (nt,nr,nn)
z1datm   average Z
z2datm (nt,nr,nn)
z2datm   average Z**2

                      Imslwrk
                      ------------------------

            working arrays for 3-d spline interpolation
                      ------------------------
nxdata 
nydata 
nzdata 
xdata (1:nxdata)
ydata (1:nydata)
zdata (1:nzdata)
fdata (1:nxdata,1:nydata,1:nzdata)
ldf 
ldf   first dimension of 3-d data array
mdf 
mdf   second dimension of 3-d data array
iflagi 
iflagi   input/output flag for 3-d spline routines
nwork2 
nwork2   size of array work2
work2 (nwork2)
work2   work array for B3VAL
nwork3 
nwork3   size of array work3
work3 (nwork3)
work3   work array for B3INT
iworki (10)
iworki   work array for B3VAL
icont 
icont   input flag for B3VAL
kxords 
kxords   order of spline fit versus x
kxords   kxords=4 (default) is cubic interpolation
kyords 
kyords   order of spline fit versus y
kyords   kyords=4 (default) is cubic interpolation
kzords 
kzords   order of spline fit versus z
kzords   kzords=4 (default) is cubic interpolation
xknots (1:nxdata+kxords)
yknots (1:nydata+kyords)
zknots (1:nzdata+kzords)
emcoef (1:nxdata,1:nydata,1:nzdata)
emcoef   spline coeff's for emissivity 
z1coef (1:nxdata,1:nydata,1:nzdata)
z1coef   spline coeff's for average-Z
z2coef (1:nxdata,1:nydata,1:nzdata)
z2coef   spline coeff's for average-Z**2

                      P93fcn
                      ------------------------

            setup and evaluation routines for spline representation of data on impurity
            radiation and charge state in POST '93 tables
                      ------------------------
readpost (fname:string)
readpost   read formatted data table for one impurity
splinem ()
splinem   construct 3-d spline representation for impurity radiation and charge
emissbs (te:real,nratio:real,ntau:real)
emissbs   radiated power per impurity atom per electron [Watts-m**3]
emissbs   te = e-temperature  [J]
emissbs   nratio = ng / ne  [none]
emissbs   ntau = ne * tau-impurity [sec/m**3]
z1avgbs (te:real,nratio:real,ntau:real)
z1avgbs   average Z of impurity
z1avgbs   te = e-temperature  [J]
z1avgbs   nratio = ng / ne  [none]
z1avgbs   ntau = ne * tau-impurity [sec/m**3]
z2avgbs (te:real,nratio:real,ntau:real)
z2avgbs   average Z**2 of impurity
z2avgbs   te = e-temperature  [J]
z2avgbs   nratio = ng / ne  [none]
z2avgbs   ntau = ne * tau-impurity [sec/m**3]

                      Reduced_ion_constants
                      ------------------------

            Constants used within reduced-ion routines
                      ------------------------
coulom 
coulom   Elementary charge
epsilo 
epsilo   Permittivity of free space
promas 
promas   Proton mass
xj7kv 
xj7kv   Joules/keV units conversion
one 
one   Unity
pi0 
pi0   Pi
zero 
zero   Zero
sumforce 
sumforce   
totmass 
totmass   
anorm 
anorm   
acci 
acci   
acci0 
acci0   
al32 (3)
al32   
miso 
miso   
nzch 
nzch   
mise 
mise   'isotope number' for electrons (=1)
ilam1 
ilam1   =1
ilam2 
ilam2   =2
ilam3 
ilam3   =3
iacci 
iacci   =4
iforc 
iforc   =5
natom (MXMISO)
natom   

                      Reduced_ion_variables
                      ------------------------

            Variables used within reduced-ion routines
                      ------------------------
capm (KXA*MXMISO*KXA*MXMISO)
capm   
capn (KXA*MXMISO*KXA*MXMISO)
capn   
caplam (KXA*MXMISO)
caplam   
fmomenta (KMXZ)
fmomenta   
denz (MXMISO*MXNZCH)
denz   
denmass (MXMISO*(MXNZCH+1))
denmass   
ela (KXA*KXA*MXMISO)
ela   
elab (KXA*MXMISO*KXA*MXMISO)
elab   
mntau (MXMISO*MXMISO)
mntau   
usol (KXA*MXNZCH*MXMISO)
usol   
sbar (KXA*MXMISO1)
sbar   
zi (MXMISO*MXNZCH)
zi   

                      Cyield
                      ------------------------

            Variables used for DIVIMP physical sputtering models
                      ------------------------
ceth (7,12)
ceth   threshold energy for physical sputtering
cetf (7,12)
cetf   Thomas-Fermi potential
cq (7,12)
cq   yield factor for phys. sputt. (atoms/ion)
ntars 
ntars   number of target materials
cidata (7,12)
cidata   flag indicating avaiability of data
redf_haas 
redf_haas   low-energy reduction of Haas97 chem sput 
redf_haas   for IOPTCHEM=7

                      Sputt_subs
                      ------------------------

            Subroutines and functions used for sputtering yields
                      ------------------------
syld96 (matt:integer,matp:integer,cion:integer,\cizb:integer,crmb:real)
yld96 (matt:integer,matp:integer,energy:real)
sputchem (ioptchem:integer,ee0:real,temp:real,\flux:real,ychem:real)

                      Emissivities
                      ------------------------

                      ------------------------
ntemp 
ntemp   number of temperature values
nlam 
nlam   number of wavelengths
nden 
nden   number of density values
etemp (ntemp)
etemp   electron temperature
lamb (nlam)
lamb   wavelength of line
eden (nden)
eden   electron density
rate (nlam,ntemp,nden)
rate   emission rate coeff
emiss (nlam,0:nx+1,0:ny+1)
emiss   emission rate
readrates (apidir:string,impfname:string)
readrates  read Isler data files
calcrates (ne:real,te:real,density:real)
calcrates  calculate emiss(1:nlam,0:nx+1,0:ny+1) via (ne,te) interpolation on Isler data

                      Pixels
                      ------------------------

                      ------------------------
nrpix 
nrpix   number of pixels in horizontal direction
nzpix 
nzpix   number of pixels in vertical direction
npd (nrpix,nzpix)
npd   number of path data points per pixel
rp1 (nrpix,nzpix)
rp1   R of 1st path-end-point for this pixel
zp1 (nrpix,nzpix)
zp1   Z of 1st path-end-point for this pixel
rp2 (nrpix,nzpix)
rp2   R of 2nd path-end-point for this pixel
zp2 (nrpix,nzpix)
zp2   Z of 2nd path-end-point for this pixel
wt (nrpix,nzpix)
wt   path length through this pixel
rminpix 
rminpix   left boundary (R) of pixel domain
rmaxpix 
rmaxpix   right boundary (R) of pixel domain
zminpix 
zminpix   lower boundary (Z) of pixel domain
zmaxpix 
zmaxpix   upper boundary (Z) of pixel domain
drpix 
drpix   pixel size in horizontal direction
dzpix 
dzpix   pixel size in vertical direction
lineintegral (arg:real,rvertex:real,zvertex:real)
lineintegral   computes the line integral of arg(nrpix,nzpix) along the path
lineintegral   (rvertex(1:2),zvertex(1:2)) where arg(ii,jj) is the pixel
lineintegral   representation of any UEDGE array arg_ue(ix,iy), obtained by
lineintegral   mapping via DCE subroutine rzxform, e.g., arg =
lineintegral   rzxform(arg_ue,rm,zm,nrpix,nzpix,rminpix,rmaxpix,zminpix,zmaxpix)

                      Package grd

                      Dimensions
                      ------------------------

            dimensioning parameters - some from flx package
                      ------------------------
idim 
idim   maximum number of angle coordinate surfaces
jdimg 
jdimg   maximum number of flux coordinate surfaces
nxefitg 
nxefitg   number of EFIT grid surfaces in x (horizontal) direction
nyefitg 
nyefitg   number of EFIT grid surfaces in y (vertical) direction
nptsg 
nptsg   maximum number of points on a flux surface (from flx package)
nix 
nix   number of coincident angle surfaces at x-point
mseg 
mseg   maximum number of segments on a flux curve
nalpha 
nalpha   number of rotated coordinate systems used for spline fits
noregsg 
noregsg   number of regions in horizontal (jh) direction
nxuse (1:2)
nxuse   number of finite-size cells along core boundary = nxcore-1 for
nxuse   double-null and limiter configurations
nworkg 
nworkg   length of 2-d spline workspace array workg
nptmp 
nptmp   length of temporary arrays for upstream and plate surfaces in
nptmp   S.R. meshmod
ndata 
ndata   data array length for SLATEC spline routine FC
nbkpt 
nbkpt   breakpoint array length for SLATEC spline routine FC
nconst 
nconst   constraint array length for SLATEC spline routine FC
nwdim 
nwdim   workspace array length for SLATEC spline routine FC
niwdim 
niwdim   workspace array length for SLATEC spline routine FC

                      Analgrd
                      ------------------------

            common block with parameters for cylindrical & rectangular (IDEAL) grid
                      ------------------------
radm 
radm  minimum 'radius' of cylinder or slab
radx 
radx  maximum 'radius' of cylinder or slab
rad0 
rad0  location of 'radial' separ'x for cylinder or slab
rscalcore 
rscalcore  scale fac to change radial dimen. of core region
za0 
za0  position of left-hand axial boundary position
zax 
zax  position of right-hand axial boundary position
zaxpt 
zaxpt  position of x-point; uniform grid to here
tiltang 
tiltang  inc. tilt angle of the divertor plate from 90 deg.
ixsnog 
ixsnog  poloidal ix where nonorthogonal mesh begins
zxpt_reset 
zxpt_reset  reset x-pt2 here if >0 for single-region mesh
alfyt 
alfyt  exponent coeff. for y (radial) grid nonuiformity
tnoty 
tnoty  shift if r(t)~del_r*tanh radial mesh profile
sratiopf 
sratiopf  ratio of effec. alfyt in priv. flux region; calc
sratiopf  internally to give same expans. rate if =0.
alfxt 
alfxt  exponent coeff. for x (axial) grid nonuiformity
tctr 
tctr  relative location of dx maximum;0, left; 1., right
bpolfix 
bpolfix  poloidal B-field for cartesian grid
btfix 
btfix  total B-field for cartesian grid 
isgdistort 
isgdistort  switch to distort poloidal grid
agsindx 
agsindx  max amplitude shift of poloidal cell face linear
agsindx  linear in radial index iy
agsrsp 
agsrsp  max amplitude shift of poloidal cell face linear
agsrsp  in real space - use either asgindx or asgrsp/not b
iynod 
iynod  iy about which asgindx distortion is centered
rnod 
rnod  value of y about which asgrsp distortion centered
ixdstar 
ixdstar  ix where poloidal distortion begins

                      Torannulus
                      ------------------------

                      ------------------------
acore 
acore  minor radius of core-edge bdry for mhdgeo=2
rm0 
rm0  major radius of annulus for mhdgeo=2
edgewid 
edgewid  width of simulated edge region for mhdgeo=2
dthlim 
dthlim  polodial angular width of limiter cell
bpol0 
bpol0  poloidal B-field for mhdgeo=2 (annulus)
btor0 
btor0  toroidal B-field for mhdgeo=2 on axis
radf (0:nym+1,0:4)
radf   minor radius of cells for mhdgeo=2
thpf (1:nxm,0:4)
thpf   poloidal angle of cells for mhdgeo=2
ibpmodel 
ibpmodel  =0, Bpol=bpol0; =1, Bpol=bpol0*rm0/R

                      Curves
                      ------------------------

            common block from original grid code
                      ------------------------
xcurveg (nptsg,jdimg)
xcurveg   xcurve(n,j) is radial coordinate of nth data point on jth flux
xcurveg   contour
ycurveg (nptsg,jdimg)
ycurveg   ycurve(n,j) is vertical coordinate of nth data point on jth flux
ycurveg   contour
npointg (jdimg)
npointg   npoint(j) is the number of data points on the jth flux contour
xxpoint 
xxpoint   radial position of the (lower) x-point
yxpoint 
yxpoint   vertical position of the (lower) x-point
rtanpl 
rtanpl   radial position of 'tangent point' (Bz = 0) on divertor plate
ztanpl 
ztanpl   vertical position of 'tangent point' (Bz = 0) on divertor plate

                      Linkco
                      ------------------------

            common block from original grid code
                      ------------------------
cmeshx (idim,jdimg)
cmeshx   radial coordinates of PLANET/DEGAS mesh
cmeshy (idim,jdimg)
cmeshy   vertical coordinates of PLANET/DEGAS mesh
ixpoint (1:3,1:2)
ixpoint   vertical indicies of x-point surfaces, for inboard and outboard
ixpoint   regions
xlbndg 
xlbndg   lower bound of horizontal coordinate
xubndg 
xubndg   upper bound of horizontal coordinate
ylbndg 
ylbndg   lower bound of vertical coordinate
yubndg 
yubndg   upper bound of vertical coordinate
yextend 
yextend   fictitious lower boundary for constructing a mesh which extends
yextend   below the EFIT mesh boundary
dsmin 
dsmin   minimum separation of data points on flux contours
dsminx 
dsminx   minimum separation of data points from true x-point
dyjump 
dyjump   a 'jump' in a flux contour occurs when dy > dyjump for consecutive
dyjump   points on the contour
alpha1 
alpha1   half-width angle that defines (up,down,left,right) directions
ityp (6,2)
ityp   flag for subroutine orthogx
ityp   ityp = 0 --> search over 1 < i < npoint
ityp   ityp = 1 --> search over 1 < i < ijump
ityp   ityp = 2 --> search over ijump+1 < i < npoint
dxleft 
dxleft   radial step size for extrapolating flux contours
ndxleft 
ndxleft   incremental number of data points for extrapolating flux contours

                      Efitg
                      ------------------------

            magnetic data on the original EFIT grid, plus other variables
                      ------------------------
runidg 
runidg   output label from EFIT in neqdsk file
xoldg (nxefitg)
xoldg   horizontal position (major radius) of grid surfaces
yoldg (nyefitg)
yoldg   vertical position of grid surfaces
foldg (nxefitg,nyefitg)
foldg   poloidal magnetic flux at EFIT grid points
fpolg (nxefitg)
fpolg   poloidal current F(psi) = R*B_toroidal from geqdsk
bscoefg (nxefitg,nyefitg)
bscoefg   2-d spline coefficients 
kxordg 
kxordg   order of the spline in the x-direction
kyordg 
kyordg   order of the spline in the y-direction
xknotg (nxefitg+kxordg)
xknotg   knot sequence in the x-direction for 2-d spline subroutines
yknotg (nyefitg+kyordg)
yknotg   knot sequence in the y-direction for 2-d spline subroutines
ldfg 
ldfg   leading dimension of 2-d spline coefficient array
iflagg 
iflagg   input/output flag for 2-d spline subroutines
workg (nworkg)
workg   work array for 2-d spline subroutines
bcentrg 
bcentrg   reference toroidal field
rcentrg 
rcentrg   major radius of point where vacuum toroidal field is bcentr
rmagxg 
rmagxg   major radius of magnetic axis
zmagxg 
zmagxg   vertical position of magnetic axis
simagxg 
simagxg   poloidal magnetic flux at the magnetic axis
sibdryg 
sibdryg   poloidal magnetic flux at the x-point
rgrid1g 
rgrid1g   major radius at inner edge of EFIT grid
xdimg 
xdimg   horizontal (radial) extent of EFIT computational grid
zdimg 
zdimg   vertical extent of EFIT computational grid
zmidg 
zmidg   vertical height of midplane above bottom of EFIT mesh
nlimg 
nlimg   number of data points on limiter/vessel boundary
xlimg (nlimg)
xlimg   radial coordinates of data points on limiter/vessel boundary
ylimg (nlimg)
ylimg   vertical coordinates of data points on limiter/vessel boundary

                      Transfm
                      ------------------------

            common block from original grid code
                      ------------------------
isegment (nptsg,jdimg)
isegment   data point n belongs to spline segment number isegment(n,j) of
isegment   contour j
isys (mseg,jdimg)
isys   spline segment k of contour j uses coordinate system isys(k,j)
isys   where isys=1  ---->   curve goes right, no rotation
isys         isys=2  ---->   curve goes up, rotate by pi/2
isys         isys=3  ---->   curve goes left, rotate by pi
isys         isys=4  ---->   curve goes down, rotate by 3*pi/2
alphasys (nalpha)
alphasys   rotation angle of the nth fixed, rotated coordinate system
ijump (jdimg)
ijump   The discontinuity in flux contour occurs between data points
ijump   i=ijump and i=ijump+1

                      Spline
                      ------------------------

            common block from original grid code
                      ------------------------
splcoef (nptsg,mseg,jdimg)
splcoef   comment needed
xknts (nptsg,mseg,jdimg)
xknts   comment needed
ncap7 (mseg,jdimg)
ncap7   comment needed

                      Argfc
                      ------------------------

            argument list for SLATEC spline routine FC
                      ------------------------
xdatag (nptsg)
xdatag   data array for independent variable x in SLATEC spline routine FC
ydatag (nptsg)
ydatag   data array for dependent variable y in SLATEC spline routine FC
sddata (nptsg)
sddata   standard deviation array for data points in SLATEC spline routine FC
nord 
nord   order of spline fit (=4 for cubic splines)
bkpt (nptsg)
bkpt   breakpoint array in SLATEC spline routine FC
xconst (nconst)
xconst   x data for constraints in SLATEC spline routine FC
yconst (nconst)
yconst   y data for constraints in SLATEC spline routine FC
nderiv (nconst)
nderiv   identifies type of constraints in SLATEC spline routine FC
mode 
mode   input/output flag for SLATEC spline routine FC
coeff (nptsg)
coeff   B-spline coefficients from SLATEC spline routine FC
wsla (nwdim)
wsla   real workspace for SLATEC spline routine FC
iwsla (niwdim)
iwsla   integer workspace for SLATEC spline routine FC

                      Inmesh
                      ------------------------

            input data from user
                      ------------------------
isspnew 
isspnew   flag for source of strike-point data
isspnew   isspnew = 0 --> strike point data from eqdsk files
isspnew           = 1 --> user-specified values (rstrike(1:2),zstrike(1:2))
rstrike (1:2)
rstrike   radial position of inboard:outboard strike point
zstrike (1:2)
zstrike   vertical position of inboard:outboard strike point
jsptrxg (1:2)
jsptrxg   index of separatrix flux surface in region
jaxisg 
jaxisg   index of magnetic axis flux surface
jming (1:2)
jming   index of first flux surface in region
jmaxg (1:2)
jmaxg   index of last flux surface in region
ilmax (1:2)
ilmax   index of last angle surface ( at divertor plate ) in each region
seedxp (idim,noregsg)
seedxp   normalized distance along core segment of separatrix
seedxp   measured from first seed point (=0.) to x-point (=100.)
seedxpxl (idim,noregsg)
seedxpxl   normalized distance along divertor leg of separatrix measured from
seedxpxl   last seed point (=0.) to x-point (=100.)
seed (idim,noregsg)
seed   absolute distance along separatrix, measured from top of region,
seed   to each angle-like mesh point
dissep (nptsg,noregsg)
dissep   absolute distance along separatrix, measured from top of region,
dissep   to each separatrix-flux-surface data point
distxp (noregsg)
distxp   absolute distance along core segment of separatrix
distxp   from first seed point to x-point
distxpxl (noregsg)
distxpxl   absolute distance along divertor leg of separatrix
distxpxl   from last seed point to x-point
x0g (noregsg)
x0g   major radius of the first seed point on the separatrix
xlast (noregsg)
xlast   major radius of the last seed point on the separatrix
y0g (noregsg)
y0g   vertical position of the first seed point on the separatrix
ylast (noregsg)
ylast   vertical position of the last seed point on the separatrix
isztest (1:2)
isztest   flag for algorithm that defines end-of-mesh on inboard, (1), 
isztest   and outboard, (2), separatrix flux contours:
isztest   = 0  -->  test on R only
isztest   = 1  -->  test on R and Z
isztest   = 2  -->  test on Z only
epslon_lim 
epslon_lim   ratio of limiter guard-cell x-width to adjacent cell
dalpha 
dalpha   fuzziness or overlap (in degrees) of angle limits associ. with alpha1

                      Transit
                      ------------------------

            common block from original grid code
                      ------------------------
xtrans (nptsg)
xtrans   x-position of data point for least-squares spline fit in rotated
xtrans   system
ytrans (nptsg)
ytrans   y-position of data point for least-squares spline fit in rotated
ytrans   system
wg (nptsg)
wg   weight of data point for least-squares spline fit in rotated
wg   system

                      System
                      ------------------------

            cliche from original grid code
                      ------------------------
istartg (mseg,jdimg)
istartg   istart(k,j) is the i-index of the first data point on spline-fit
istartg   segment k of contour j, including any 'extra' data points.
iendg (mseg,jdimg)
iendg   iend(k,j) is the i-index of the last data point on spline-fit
iendg   segment k of contour j, including any 'extra' data points.
m (mseg,jdimg)
m   m(k,j) is the total number of data points for spline-fit segment k
m   of contour j, including any 'extra' data points.
nseg (jdimg)
nseg   comment needed
ixpointc (1:3,1:2)
ixpointc   the i-index of x-point data in (xcurve,ycurve) arrays; j-index is
ixpointc   jsptrx.
xwork (nptsg)
xwork   work array used in subroutine prune
ywork (nptsg)
ywork   work array used in subroutine prune
istartc (noregsg)
istartc   work array used in subroutine sow
iendc (noregsg)
iendc   work array used in subroutine sow

                      Aeqdskg
                      ------------------------

            information from the A-file produced by the EFIT code
                      ------------------------
eshotg 
eshotg   shot number from EFIT
etimeg 
etimeg   time slice from EFIT
rsepsg 
rsepsg   major radius of x-point
zsepsg 
zsepsg   vertical position of x-point
rvsing 
rvsing   major radius of inboard strike point
zvsing 
zvsing   vertical position of inboard strike point
rvsoutg 
rvsoutg   major radius of outboard strike point
zvsoutg 
zvsoutg   vertical position of outboard strike point

                      UEgrid
                      ------------------------

            input/output data for defining the grid in the UEDGE code
                      ------------------------
ixtop 
ixtop   ix index of top 'angle' surface opposite the x-point

                      Mmod
                      ------------------------

            parameters that determine non-orthogonal mesh modifications
            Note: parameter ismmon has been moved to group Share of the com package
                      ------------------------
cmeshx0 (idim,jdimg)
cmeshx0   working copy of orthogonal mesh, used by meshmod3 (for ismmon=3)
cmeshy0 (idim,jdimg)
cmeshy0   working copy of orthogonal mesh, used by meshmod3 (for ismmon=3)
dsc (nptsg)
dsc   temporary array for subroutine meshmod
dsc   distance (along x,ycurve) downstream from top-of-mesh 
dsc   to each flux surface data point
xcrv (nptsg)
xcrv   temporary array for x-coordinates in subroutine meshmod
ycrv (nptsg)
ycrv   temporary array for y-coordinates in subroutine meshmod
dsm (idim)
dsm   distance (along cmeshx,y) downstream from top-of-mesh
dss (idim)
dss   distance (along separatrix cmeshx,y) downstream from top-of-mesh
dssleg (idim)
dssleg   distance (along separatrix cmeshx,y) downstream from x-point
dsmesh (idim)
dsmesh   temporary array for subroutine meshmod; distance (along x,ycurve)
dsmesh   downstream from top-of-mesh to meshpoints
dsmesh0 (idim)
dsmesh0   temporary array for subroutine meshmod
dsmesh0   distance from top-of-mesh to meshpoints for ismmon=0 option
dsmesh1 (idim)
dsmesh1   temporary array for subroutine meshmod
dsmesh1   distance from top-of-mesh to meshpoints for ismmon=1 option
dsmesh2 (idim)
dsmesh2   temporary array for subroutine meshmod
dsmesh2   distance from top-of-mesh to meshpoints for ismmon=2 option
xmsh (idim)
xmsh   temporary array for x-coordinates in subroutine meshmod
ymsh (idim)
ymsh   temporary array for y-coordinates in subroutine meshmod
ntop1 
ntop1   number of data points on the inboard top-of-mesh reference surface
rtop1 (ntop1)
rtop1   radial position of data points on the inboard top-of-mesh
rtop1   reference surface
ztop1 (ntop1)
ztop1   vertical position of data points on the inboard top-of-mesh
ztop1   reference surface
ntop2 
ntop2   number of data points on the outboard top-of-mesh reference
ntop2   surface
rtop2 (ntop2)
rtop2   radial position of data points on the outboard top-of-mesh
rtop2   reference surface
ztop2 (ntop2)
ztop2   vertical position of data points on the outboard top-of-mesh
ztop2   reference surface
istream 
istream   option parameter for defining fixed upstream reference surface
istream   istream=0 midplane+cut(ismmon=1) or top-of-mesh(ismmon=2)
istream   istream=1 user-defined upstream surface arrays
nupstream1 
nupstream1   number of data points on the inboard upstream reference surface
rupstream1 (nupstream1)
rupstream1   radial position of data points on the inboard upstream reference
rupstream1   surface
zupstream1 (nupstream1)
zupstream1   vertical position of data points on the inboard upstream reference
zupstream1   surface
nupstream2 
nupstream2   number of data points on the outboard upstream reference surface
rupstream2 (nupstream2)
rupstream2   radial position of data points on the outboard upstream reference
rupstream2   surface
zupstream2 (nupstream2)
zupstream2   vertical position of data points on the outboard upstream
zupstream2   reference surface
ndnstream1 
ndnstream1   number of data points on the inboard downstream reference surface
rdnstream1 (ndnstream1)
rdnstream1   radial position of data points on the inboard downstream reference
rdnstream1   surface
zdnstream1 (ndnstream1)
zdnstream1   vertical position of data points on the inboard downstream
zdnstream1   reference surface
ndnstream2 
ndnstream2   number of data points on the outboard downstream reference surface
rdnstream2 (ndnstream2)
rdnstream2   radial position of data points on the outboard downstream
rdnstream2   reference surface
zdnstream2 (ndnstream2)
zdnstream2   vertical position of data points on the outboard downstream
zdnstream2   reference surface
iplate 
iplate   option parameter for defining divertor plates
iplate   iplate=0 orthogonal plates
iplate   iplate=1 user-defined divertor plates
nplate1 
nplate1   number of data points on the inboard divertor plate surface
rplate1 (nplate1)
rplate1   radial position of data points on the inboard divertor plate surface
zplate1 (nplate1)
zplate1   vertical position of data points on the inboard divertor plate
zplate1   surface
nplate2 
nplate2   number of data points on the outboard divertor plate surface
rplate2 (nplate2)
rplate2   radial position of data points on the outboard divertor plate
rplate2   surface
zplate2 (nplate2)
zplate2   vertical position of data points on the outboard divertor plate
zplate2   surface
ntop 
ntop   temporary variable for subroutine meshmod
rtop (nptmp)
rtop   temporary array for subroutine meshmod
ztop (nptmp)
ztop   temporary array for subroutine meshmod
ntop0 
ntop0   temporary variable for subroutine meshlim
rtop0 (nptmp)
rtop0   temporary array for subroutine meshlim
ztop0 (nptmp)
ztop0   temporary array for subroutine meshlim
nbot 
nbot   temporary variable for subroutine meshlim
rbot (nptmp)
rbot   temporary array for subroutine meshlim
zbot (nptmp)
zbot   temporary array for subroutine meshlim
nupstream 
nupstream   temporary variable for subroutine meshmod
rupstream (nptmp)
rupstream   temporary array for subroutine meshmod
zupstream (nptmp)
zupstream   temporary array for subroutine meshmod
ndnstream 
ndnstream   temporary variable for subroutine meshmod
rdnstream (nptmp)
rdnstream   temporary array for subroutine meshmod
zdnstream (nptmp)
zdnstream   temporary array for subroutine meshmod
nplate 
nplate   temporary variable for subroutine meshmod
rplate (nptmp)
rplate   temporary array for subroutine meshmod
zplate (nptmp)
zplate   temporary array for subroutine meshmod
nplate0 
nplate0   temporary variable for subroutine meshmod
rplate0 (nptmp)
rplate0   temporary array for subroutine meshmod
zplate0 (nptmp)
zplate0   temporary array for subroutine meshmod
dsnorm (idim)
dsnorm   temporary array for subroutine meshmod2
wtold 
wtold   weight factor for spatial smoothing of angle-like mesh surfaces
wtold   wtold=1.0 ==> no smoothing
wtold   wtold=0.5 ==> (1,2,1) relative weighting of (j-1,j,j+1)
wtold   wtold=0.0 ==> (1,0,1) relative weighting of (j-1,j,j+1)
nsmooth 
nsmooth   number of times to apply the smoothing algorithm to each
nsmooth   angle-like surface after non-orthogonal plate construction
fuzzm 
fuzzm   a measure of the 'fuzziness' in meshpoint coordinates  
delmax 
delmax   estimated maximum deviation of mesh points from exact flux
delmax   surfaces (used only in subroutine smooth)
wtmesh1 
wtmesh1   weight factor for combining ismmon=1 and ismmon=2 meshes
wtmesh1   wtmesh1=1 ---> same as ismmon=1
wtmesh1   wtmesh1=0 ---> same as ismmon=2
wtm1 (idim)
wtm1   temporary array of weight factors for merging limiter mesh
wtm1   with original (unmodified) mesh
dmix0 
dmix0   normalized poloidal mixing length for combining mesh0 with mesh12
dmix0   =0. --> abrupt  change from orthogonal mesh to mesh12 at upstream 
dmix0           position
dmix0   =1. --> gradual change from orthogonal mesh to mesh12 between 
dmix0           upstream and downstream positions
cmeshx3 (idim,jdimg)
cmeshx3   reference mesh for flamefront modifications
cmeshy3 (idim,jdimg)
cmeshy3   reference mesh for flamefront modifications
nff1 
nff1   number of data points on the inboard flamefront
rff1 (nff1)
rff1   radial position of data points on the inboard flamefront
zff1 (nff1)
zff1   vertical position of data points on the inboard flamefront
nff2 
nff2   number of data points on the outboard flamefront
rff2 (nff2)
rff2   radial position of data points on the outboard flamefront
zff2 (nff2)
zff2   vertical position of data points on the outboard flamefront
nff 
nff   temporary variable for subroutine meshff
rff (nptmp)
rff   temporary array for subroutine meshff
zff (nptmp)
zff   temporary array for subroutine meshff
dsmesh3 (idim)
dsmesh3   temporary array for subroutine meshff
dsmesh3   distance from top-of-mesh to original meshpoints (no flamefront)
dsmeshff (idim)
dsmeshff   temporary array for subroutine meshff
dsmeshff   distance from top-of-mesh to modified meshpoints (flamefront)
cwtffu 
cwtffu   exponent for weight function variation between x-point and flamefront
cwtffu   wt(ix)=wtff*fac(ix)**cwtff where fac(ix) varies linearly from
cwtffu   zero at xpoint to unity at flamefront.
cwtffd 
cwtffd   exponent for weight function variation between flamefront and plate
cwtffd   wt(ix)=wtff*fac(ix)**cwtff where fac(ix) varies linearly from
cwtffd   zero at plate to unity at flamefront.
isxtform 
isxtform   flag for choosing various forms of x(ix) near flamefront
isxtform   =1 --> specify slope factor at flamefront only (default)
isxtform   =2 --> specify slope factor at flamefront and upstream
isxtform   =3 --> specify slope factor at flamefront, upstream and downstream
iswtform 
iswtform   flag for choosing various forms of weight factors near flamefront
iswtform   =0 --> wt(ix)=wtff for all ix (default)
iswtform   =1 --> wt(ix)~wtff*abs(ix-ixlimit)**cwtff between flamefront and
iswtform          limiting surface at xpoint (upstream) or plate (downstream).
wtff1 
wtff1   maximum weight factor for combining meshes w and w/o flamefront
wtff1   wtff=1 ---> full flamefront mesh
wtff1   wtff=0 ---> no flamefront modifications
slpxff1 
slpxff1   slope factor at flamefront position
slpxff1   slpxff < 1  makes mesh finer at flamefront
slpxff1   slpxff > 1  makes mesh coarser at flamefront
slpxffu1 
slpxffu1   slope factor at upstream limit (x-point) of flamefront mesh
slpxffu1   slpxuu < 1  makes mesh finer
slpxffu1   slpxuu > 1  makes mesh coarser
slpxffd1 
slpxffd1   slope factor at downstream limit (plate) of flamefront mesh
slpxffd1   slpxuu < 1  makes mesh finer
slpxffd1   slpxuu > 1  makes mesh coarser
nxdff1 
nxdff1   number of cells between flame front and divertor plate
nxdff1   on inner leg (region 1)
wtff2 
wtff2   maximum weight factor for combining meshes w and w/o flamefront
wtff2   wtff=1 ---> full flamefront mesh
wtff2   wtff=0 ---> no flamefront modifications
slpxff2 
slpxff2   slope reduction factor for flamefront mesh
slpxff2   slpxff < 1  makes mesh finer at flamefront
slpxff2   slpxff > 1  makes mesh coarser at flamefront
slpxffu2 
slpxffu2   slope factor at upstream limit (x-point) of flamefront mesh
slpxffu2   slpxuu < 1  makes mesh finer
slpxffu2   slpxuu > 1  makes mesh coarser
slpxffd2 
slpxffd2   slope factor at downstream limit (plate) of flamefront mesh
slpxffd2   slpxuu < 1  makes mesh finer
slpxffd2   slpxuu > 1  makes mesh coarser
nxdff2 
nxdff2   number of cells between flame front and divertor plate
nxdff2   on outer leg (region 2)

                      Refinex
                      ------------------------

            data used for mesh refinement near the x-point
                      ------------------------
isrefxptn 
isrefxptn   flag for choosing x-point mesh refinement algorithm
isrefxptn   =0  old interpolation method
isrefxptn   =1  new flux-surface-based method
nxmod 
nxmod   number of 'upstream' poloidal cells (per quadrant) in the
nxmod   original mesh that we modify by calling subroutine refinex
alfxptl 
alfxptl   use as alfxpt for cells below(l) the x-pt;
alfxptl   frac=(i/(nxxpt+nxmod))**alfxpt for extra x-pt grid spacing below x-pt
alfxpt2l 
alfxpt2l   use as alfxpt2 for cells below(l) the x-pt;
alfxpt2l   frac2=(i/(nxxpt+nxmod-1))**alfxpt2 for mixing fixed lngth & 
alfxpt2l   flux-surface length in adding extra x-pt cells below x-pt
alfxptu 
alfxptu   use as alfxpt for cells above(u) the x-pt; 
alfxptu   frac=(i/(nxxpt+nxmod))**alfxpt for extra x-pt grid spacing above x-pt
alfxpt2u 
alfxpt2u   use as alfxpt2 for cells above(u) the x-pt; 
alfxpt2u   frac2=(i/(nxxpt+nxmod-1))**alfxpt2 for mixing fixed lngth & 
alfxpt2u   flux-surface length in adding extra x-pt cells above x-pt
alfxpt 
alfxpt   work var for alfxptl,u for below(l)/above(u) x-pt
alfxpt   frac=(i/(nxxpt+nxmod))**alfxpt for setting extra x-pt grid spacing
alfxpt2 
alfxpt2   work var for alfxptsl,u for below(l)/above(u) x-pt
alfxpt2   frac2=(i/(nxxpt+nxmod-1))**alfxpt2 for mixing fixed lngth & 
alfxpt2   flux-surface length in adding extra x-pt cells
rsu (0:nym+2)
rsu   working array (for each quadrant) that contains r-coord's of
rsu   upstream reference surface
zsu (0:nym+2)
zsu   working array (for each quadrant) that contains z-coord's of
zsu   upstream reference surface
rsx (0:nym+2)
rsx   working array (for each quadrant) that contains r-coord's of
rsx   reference surface passing thru the x-point
zsx (0:nym+2)
zsx   working array (for each quadrant) that contains z-coord's of
zsx   reference surface passing thru the x-point
nflux 
nflux   number of data points in the working arrays rflux & zflux
rflux (nptsg)
rflux   working array that contains r-coord's of flux surface data points
zflux (nptsg)
zflux   working array that contains z-coord's of flux surface data points
dsflux (nptsg)
dsflux   working array that contains cumulative distance from upstream
dsflux   reference surface
rmm (0:nym,0:nxm)
rmm   working array that contains r-coord's of angle-like surfaces
rmm   in refined region near x-point
zmm (0:nym,0:nxm)
zmm   working array that contains z-coord's of angle-like surfaces
zmm   in refined region near x-point
nsmoothx 
nsmoothx   number of times to apply the smoothing algorithm to each
nsmoothx   angle-like surface after mesh refinement near the x-point

                      Xmesh
                      ------------------------

            data for analytic definition of xfcn(t) on separatrix
                      ------------------------
ndat 
ndat   number of data values for xfcn(t)
xdat (ndat)
xdat   data values for xfcn
tdat (ndat)
tdat   data values for t
kxmesh 
kxmesh   switch parameter for choosing model that defines x-mesh :
kxmesh         kxmesh=0        use old model (manual def. of seed points)
kxmesh         kxmesh=1        use linear*rational form for x(t)
kxmesh         kxmesh=2        use linear*exponential form for x(t)
kxmesh         kxmesh=3        use spline form for x(t)
kxmesh         kxmesh=4        use exponential+spline form for x(t)
slpxt 
slpxt   slope enhancement factor for x(t) near the 'top' of the core
slpxt   plasma
alfx (2)
alfx   log( dx(n+1)/dx(n) ) for 'gas' cells near the divertor plates
dxgas (2)
dxgas   poloidal size of first 'gas' cell at inboard and outboard plates
nxgas (2)
nxgas   number of poloidal 'gas' cells at inboard and outboard plates
dt1 
dt1   normalized-index distance (t) from inboard plate to 'extra' data
dt1   point
dx1 
dx1   physical distance (x) from inboard plate to 'extra' data point
dt2 
dt2   normalized-index distance (t) from outboard plate to 'extra' data
dt2   point
dx2 
dx2   physical distance (x) from outboard plate to 'extra' data point
ileft 
ileft   type of end condition at the left endpoint
ileft       = 1  first derivative specified by dleft
ileft       = 2  second derivative specified by dleft
dleft 
dleft   derivative at left endpoint
iright 
iright   type of end condition at the right endpoint
iright       = 1  first derivative specified by dright
iright       = 2  second derivative specified by dright
dright 
dright   derivative at right endpoint
kord 
kord   order of spline (=4 for cubic interpolation)
ndatp2 
ndatp2   NDATP2 = NDAT+2
kntopt 
kntopt   knot selection option flag
tknt (ndatp2+4)
tknt   knot locations
z1work (5*(ndat+2))
z1work   work array for BINT4 spline construction
z1cscoef (ndatp2)
z1cscoef   spline coefficients
wrk1 (3*kord)
wrk1   work array for B1VAL spline evaluation
iflag1 
iflag1   output status flag from B1VAL

                      Dnull_temp
                      ------------------------

            temporary storage for upper and bottom halves of double-null mesh
                      ------------------------
nxmb 
nxmb   number of cells in poloidal direction
nymb 
nymb   number of cells in radial direction
rmb (0:nxmb+1,0:nymb+1,0:4)
rmb   radial cell position
zmb (0:nxmb+1,0:nymb+1,0:4)
zmb   vertical cell position
ixpt1b 
ixpt1b   poloidal index of cells at x-point on inboard side
ixtopb 
ixtopb   poloidal index of cells at top of mesh
ixpt2b 
ixpt2b   poloidal index of cells at x-point on outboard side
iysptrxb 
iysptrxb   radial index of cells just inside the separatrix
nxmu 
nxmu   number of cells in poloidal direction
nymu 
nymu   number of cells in radial direction
rmu (0:nxmu+1,0:nymu+1,0:4)
rmu   radial cell position
zmu (0:nxmu+1,0:nymu+1,0:4)
zmu   vertical cell position
ixpt1u 
ixpt1u   poloidal index of cells at x-point on inboard side
ixtopu 
ixtopu   poloidal index of cells at top of mesh
ixpt2u 
ixpt2u   poloidal index of cells at x-point on outboard side
iysptrxu 
iysptrxu   radial index of cells just inside the separatrix

                      Xfcn
                      ------------------------

            contains various x-mesh functional forms
                      ------------------------
xfcn (t)
xfcn   defines analytic x-mesh in terms of normalized cell index 0 < t <
xfcn   1.  the divertor leg distribution has a rational function form.
xfcn2 (t)
xfcn2   defines analytic x-mesh in terms of normalized cell index 0 < t <
xfcn2   1.  the divertor leg distribution has a linear*exponential
xfcn2   function form.
xfcn3 (t)
xfcn3   defines x-mesh in terms of normalized cell index 0 < t < 1.  a
xfcn3   cubic spline connects points.
xfcn4 (t,nxtotal)
xfcn4   defines x-mesh in terms of normalized cell index 0 < t < 1.  form
xfcn4   is exponential near plates and cubic spline for interior region
xcscoef ()
xcscoef   calls spline-fitting routine BINT4

                      Driver
                      ------------------------

            user-callable subroutines
                      ------------------------
setidim ()
setidim   sets dimensions for angle-like arrays
grdrun ()
grdrun   main driver routine for grd package
ingrd ()
ingrd   sets input data for grd package
codsys (j,icood,iseg,is,dy,region:integer,alpha1)
codsys   constructs segmented spline fits to a flux contour
findalph (nsys,iseg,j,xob,yob,alphab)
findalph   finds the rotation angle.
readflx ()
readflx   read input data from flx package in file flx-grd.
prune ()
prune   inserts x-points on the separatrix contours, and removes
prune   closely-spaced points on all contours.
extend ()
extend   extrapolates contours, if necessary, below the plate surface.
splfit ()
splfit   constructs segmented spline fits to flux contours using s.r. codsys
sow ()
sow   generates the seed points along the separatrix
meshgen (region:integer)
meshgen   generates a mesh by finding orthogonal curves to (xcurve,ycurve)
orthogx (ixtyp,i,j0,j,xob,yob,alphab)
orthogx   constructs the orthogonal point on j from the given x-point
orthogx   coordinates (xob,yob); the search is limited to the
orthogx   (upper,lower,entire) length of flux surface j by ixtyp=(1,2,0); On
orthogx   output, alpha is the local rotation angle of the jth flux surface
orthogx   at (xob,yob).  Note that (xob,yob) are used as both input and
orthogx   output arguments.  (i,j0) are informational only.
orthogrd (ixtyp,i,j0,j,xob,yob,alphab)
orthogrd   constructs the orthogonal point on j from the given point (xob,yob)
orthogrd   on j0; the search is limited to the (upper,lower,entire) length of
orthogrd   flux surface j by ixtyp=(1,2,0); alpha is the local rotation angle
orthogrd   of the jth flux surface at (xob,yob).  Note that (xob,yob,alpha)
orthogrd   are used as both input and output arguments.  (i,j0) are
orthogrd   informational only.
readgrid (fname:string,runid:string)
readgrid   This subroutine reads a formatted data file of (R,Z) coordinates
readgrid   and magnetic field data for the UEDGE code.
writesn (fname:string,runid:string)
writesn   This subroutine converts (cmeshx,cmeshy) data into (rm,zm) data
writesn   and writes a formatted data file of (R,Z) coordinates
writesn   and magnetic field data for a single-null divertor configuration.
writedn (fname:string,runid:string)
writedn   This subroutine converts (cmeshx,cmeshy) data into (rm,zm) data
writedn   and writes a formatted data file of (R,Z) coordinates
writedn   and magnetic field data for the outboard half of an up/down
writedn   symmetric double-null configuration.
writedata (fname:string,runid:string)
writedata   This subroutine writes a formatted data file of (R,Z) coordinates
writedata   and magnetic field data for the UEDGE code.
writednf (fname:string,runid:string)
writednf   This subroutine writes a formatted data file of (R,Z) coordinates
writednf   and magnetic field data for a full double-null geometry.
intersect2 (x1:real,y1:real,i1min:integer,i1max:integer,\x2:real,y2:real,i2min:integer,i2max:integer,\xc:real,yc:real,i1c:integer,i2c:integer,\fuzz:real,ierr:integer)
intersect2       Find the intersection of the two segmented curves :
intersect2       (x1(i),y1(i)) i=i1min,i1max and (x2(i),y2(i)) i=i2min,i2max
intersect2       Return the intersection point (xc,yc) and the node indices i1c
intersect2       and i2c such that the intersection point lies between nodes
intersect2       i1c and i1c+1 of curve 1 and nodes ic2 and ic2+1 of curve 2.
intersect2       fuzz is the absolute uncertainty in the data point positions.
intersect2       Return error flag ierr=1 if no intersection is found.
meshmod2 (region:integer)
meshmod2   generates a modified mesh with the same normalized distribution of
meshmod2   points along every flux surface.
smooth (i:integer,j1:integer,j2:integer)
smooth   smoothes spatial irregularities in angle-like surface (i) between
smooth   flux surfaces (j1) and (j2) ---> modified cmeshx,y
writeue ()
writeue   convert from DEGAS-indexed (cmeshx,cmeshy) to UEDGE-indexed
writeue   (rm,zm) and write these into an ascii grid-data file, gridue.
grd2wdf ()
grd2wdf   write grid information for DEGAS namelist to unformatted file
grd2wdf   grd-wdf
evalspln (iseg:integer,j:integer,xo:real,yo:real)
evalspln   evaluates the spline representation for the y-coordinate and its
evalspln   derivatives (yo(1:4)) on a segment (iseg) of a flux surface (j) at
evalspln   the input x-coordinate (xo), where (xo,yo) are in the
evalspln   local/rotated coordinate system of the spline (see isys(iseg,j)
evalspln   and the corresponding alphasys for the rotation angle)
idealgrd ()
idealgrd   calculates either a cylindrical mesh for mhdgeo=0, or a cartesian
idealgrd   mesh for mhdgeo=-1
gett ()
gett   generates top-of-mesh reference surfaces for use by meshmod3
getu ()
getu   generates upstream reference surfaces for use by meshmod3
getd ()
getd   generates downstream reference surfaces for use by meshmod3
getp ()
getp   generates orthogonal plate reference surfaces for use by meshmod3
meshmod3 (region:integer)
meshmod3   generates a modified mesh as defined by parameters wtmesh1 and
meshmod3   dmix0, and by arrays for the plate and stream reference surfaces.
smoother ()
smoother   applies smoothing algorithm to all angle-like flux surfaces in
smoother   the mesh; number of applications is controlled by nsmooth.
smoother2 ()
smoother2   applies smoothing algorithm to all angle-like flux surfaces in
smoother2   the outboard half of the mesh only
meshff (region:integer)
meshff   generates a modified mesh with refinement near a flamefront
meshff   surface; degree of modification is controlled by wtff and slpxff.
meshff   flamefront surface is defined in arrays rff1,zff1,rff2,zff2.
fpoloidal (psi:real)
fpoloidal   evaluates the flux function F(psi) = R*B_toroidal for
fpoloidal   spheromak MHD equilibria with constant lambda in the SOL
fpoloidal   and flux function fpol(psi) from geqdsk in the core.
psif (r,z)
psif   evaluates the 2-D spline for psi
brf (r,z)
brf   evaluates the radial magnetic field from the 2-D spline for psi
bzf (r,z)
bzf   evaluates the vertical magnetic field from the 2-D spline for psi
rsurface (quadrant:integer)
rsurface   copies angle-like surface data to reference surface arrays
rsurface   rsu,zsu,rsx,zsx for x-point mesh refinement
fluxcurve (quadrant:integer,iy:integer)
fluxcurve   copies flux surface data from (xcurveg,ycurveg) to the work
fluxcurve   arrays (rflux,zflux) used for x-point mesh refinement
refinexm ()
refinexm   refine the mesh in the poloidal direction near the x-point
refinexm   with parameters nxmod, nxxpt and alfxpt set by user
refine_xpt ()
refine_xpt   refine the mesh in the poloidal direction near the x-point
refine_xpt   with parameters nxmod, nxxpt and alfxpt set by user
smoothx (rmm:real,zmm:real,nd1:integer,nd2:integer,\iy1:integer,iy2:integer,quadrant:integer)
smoothx   smooth spatial irregularities in the angle-like surface
smoothx   defined by the arrays rmm(iy1:iy2) and zmm(iy1:iy2) while ensuring
smoothx   that the smoothed points lie exactly on flux surfaces.
mapdnbot ()
mapdnbot   maps bottom-half mesh data (rmb,zmb) into mesh arrays (rm,zm)
mapdnbot   for full double null and sets special mesh indices
mapdntop ()
mapdntop   maps upper-half mesh data (rmu,zmu) into mesh arrays (rm,zm)
mapdntop   for full double null and sets special mesh indices
magnetics (ixmin,ixmax,iymin,iymax)
magnetics   evaluate magnetic field data for mesh cells (rm,zm) with
magnetics   indices in the range ixmin<=ix<=ixmax and iymin<=iy<=iymax;
magnetics   uses 2-d spline fit to eqdsk data
add_guardc_tp ()
add_guardc_tp   construct infinitesimal guard cells at target plates for full
add_guardc_tp   double-null mesh

                      Package flx

                      Dimflx
                      ------------------------

            dimensioning parameters - to be passed to grd package
                      ------------------------
jdim 
jdim   maximum number of flux coordinate surfaces
noregs 
noregs   number of regions in the horizontal direction
npts 
npts   maximum number of points on a flux surface from contouring package
nsearch 
nsearch   maximum number search regions for contouring package
nworkf 
nworkf   length of 2-d spline workspace array workf

                      Flxin
                      ------------------------

                      ------------------------
istchkon 
istchkon   switch for imposing limits on the polar angle about (rmagx,zmagx)
istchkon   of (r,z) points on flux contours.
istchkon   =0 no limits
istchkon   =1 limits are defined by theta_split, thetax, dtheta_exclude,
istchkon               dtheta_overlap_sol and dtheta_overlap_pf
isthmmxn 
isthmmxn   switch that controls expressions for thetamin and thetamax when
isthmmxn   istchkon=1 for 'dnbot' configurations:
isthmmxn   =0     uses same theta_split for in/outboard halves
isthmmxn   =1     uses pi/twopi in place of theta_split for in/outboard halves
dtheta_exclude (1:2)
dtheta_exclude   angular width of region where SOL flux contours are excluded
dtheta_exclude   index 1 refers to inboard flux contours; 2 refers to outboard contours
dtheta_overlap_sol (1:2)
dtheta_overlap_sol   angular width over which SOL flux contours can overlap
dtheta_overlap_sol   with flux contours in the adjacent region.
dtheta_overlap_sol   index 1 refers to inboard flux contours; 2 refers to outboard contours
dtheta_overlap_pf (1:2)
dtheta_overlap_pf   angular width over which p.f. flux contours can overlap
dtheta_overlap_pf   with flux contours in the adjacent region.
thetax 
thetax   computed poloidal angle of xpoint relative to magnetic axis
thetamin (1:2)
thetamin   computed minimum poloidal angle of flux contour data
thetamin   index 1 refers to inboard flux contours; 2 refers to outboard contours
thetamax (1:2)
thetamax   computed maximum poloidal angle of flux contour data
thetamax   index 1 refers to inboard flux contours; 2 refers to outboard contours
jmin (2)
jmin   index of first flux surface for inboard and outboard half of mesh
jmax (2)
jmax   index of last flux surface for inboard and outboard half of mesh
jsptrx (2)
jsptrx   separatrix flux surface index for inboard and outboard half of mesh
jaxis 
jaxis   magnetic axis 'flux surface' index that divides inboard and outboard mesh
imagx 
imagx   horizontal (R) index of the refined-EFIT cell containing the magnetic axis
jmagx 
jmagx   vertical (Z) index of the refined-EFIT cell containing the magnetic axis
iseps 
iseps   horizontal (R) index of the refined-EFIT cell containing the x-point
jseps 
jseps   vertical (Z) index of the refined-EFIT cell containing the x-point
icutoff1 
icutoff1   horizontal (R) index of the refined-EFIT cell containing xcutoff1
jcutoff1 
jcutoff1   vertical (Z) index of the refined-EFIT cell containing ycutoff1
slpyt 
slpyt   scaling factor for radial mesh near double-null separatrices -
slpyt      - mesh size is scaled by slpyt near inner separatrix
slpyt      - mesh size is scaled by 1/slpyt near outer separatrix
slp2fac 
slp2fac   scale factor for radial mesh in asymmetric double-null configurations
slp2fac   (see function rho3dn for details)
slp2fac   = 1. for uniform mesh between separatrices
slp2fac   < 1. for finer mesh at innermost separatrix
slp2fac   > 1. for coarser mesh at innermost separatrix
slp3fac 
slp3fac   scale factor for radial mesh in asymmetric double-null configurations
slp3fac   (see function rho3dn for details)
slp3fac   = 1. for uniform mesh between separatrices
slp3fac   < 1. for finer mesh at outermost separatrix
slp3fac   > 1. for coarser mesh at outermost separatrix
psifac 
psifac   multiplicative factor in normalized separatrix flux
psifac   to ensure that contour is just outside the x-point.
psi0sep1 
psi0sep1   normalized flux value at lower x-point
psi0sep2 
psi0sep2   normalized flux value at upper x-point
psi0max_inner 
psi0max_inner   normalized flux value at wall on inboard side of magnetic axis
psi0max_outer 
psi0max_outer   normalized flux value at wall on outboard side of magnetic axis
psi0min2_upper 
psi0min2_upper   normalized flux value at private flux boundary near upper x-point
psi0min2_lower 
psi0min2_lower   normalized flux value at private flux boundary near lower x-point
psi0min1 
psi0min1   normalized flux value at innermost core flux surface
psi0min2 
psi0min2   normalized flux value at innermost private flux surface
psi0sep 
psi0sep   normalized flux value at separatrix flux surface (just slightly outside)
psi0max 
psi0max   normalized flux value at wall on outboard side of magnetic axis
psi0lim 
psi0lim   normalized flux value where core radial mesh can be concentrated
sfaclim 
sfaclim   multiplicative factor for slope of psi0(iy) distribution at psi0lim
sfaclim   sfaclim = 1 --> nearly uniform
sfaclim   sfaclim < 1 --> more concentrated near psi0lim
alfcy_inner 
alfcy_inner   exponential factor for  distribution of SOL flux contours (inboard)
alfcy_inner   alfcy << 1 --> uniform
alfcy_inner   alfcy >> 1 --> concentrated near separatrix
alfcy 
alfcy   exponential factor for  distribution of SOL flux contours (outboard)
alfcy   alfcy << 1 --> uniform
alfcy   alfcy >> 1 --> concentrated near separatrix
xoverlap (2)
xoverlap   overlap parameters for inboard and outboard flux contours
xoverlap   (in units of dxefit)
rho (0:nym)
rho   temporary array for normalized flux values on B2/UEDGE flux surfaces
tflx (0:nym)
tflx   temporary array for indicies of B2/UEDGE flux surfaces
psitop (1:jdim)
psitop   array of un-normalized pol. mag. flux values across the midplane 
psibot (1:jdim)
psibot   array of un-normalized pol. mag. flux values across both divertor plates
iseqdskr 
iseqdskr   switch (=1) for reflecting eqdsk data about the midplane;
iseqdskr   used with geometry='uppersn' and for upper half-mesh of geometry='dnull'
kymesh 
kymesh   option flag for setting flux contour values that define radial mesh
kymesh   =0 user sets arrays psitop (midplane) and psibot (div plates)
kymesh   =1 psitop and psibot are analytic forms (see rho1); adjust via alfcy
kymesh   =2 psitop and psibot are analytic forms (see rho5); uniform core
xcutoff1 
xcutoff1   inboard cutoff radius for flux contours
ycutoff1 
ycutoff1   lower vertical cutoff for flux contours
mdsefit 
mdsefit   Set this flag to 1 if the data is read in from Mdsplus
mdsefit   Prevents inflx from calling readefit.

                      Workdn
                      ------------------------

            some working arrays for full double-null configurations
                      ------------------------
psi0_mp_inner (0:nym)
psi0_mp_inner   normalized flux values at radial mesh points of inner midplane
psi0_mp_outer (0:nym)
psi0_mp_outer   normalized flux values at radial mesh points of outer midplane
psi0_dp_lower_inner (0:nym)
psi0_dp_lower_inner   normalized flux values at radial mesh points of lower inner divertor plate
psi0_dp_lower_outer (0:nym)
psi0_dp_lower_outer   normalized flux values at radial mesh points of lower outer divertor plate
psi0_dp_upper_inner (0:nym)
psi0_dp_upper_inner   normalized flux values at radial mesh points of upper inner divertor plate
psi0_dp_upper_outer (0:nym)
psi0_dp_upper_outer   normalized flux values at radial mesh points of upper outer divertor plate

                      Inpf0
                      ------------------------

            flux contour control variables for each sub-region, nsearch:
                      ------------------------
plflux0 (jdim,nsearch)
plflux0   poloidal flux contour values
ncmin0 (nsearch)
ncmin0   flux index of first poloidal flux curve
ncmax0 (nsearch)
ncmax0   flux index of last poloidal flux curve
iserch0 (nsearch)
iserch0   horizontal (x) index of starting point for flux contour search
iserch0   on refined EFIT grid
jserch0 (nsearch)
jserch0   vertical (y) index of starting point for flux contour search
jserch0   on refined EFIT grid
istepf0 (nsearch)
istepf0   horizontal step size (on refined EFIT mesh) for contour search path
jstepf0 (nsearch)
jstepf0   vertical step size (on refined EFIT mesh) for contour search path
xminf0 (nsearch)
xminf0   radial cutoff for contours at inner edge of efit domain
xmaxf0 (nsearch)
xmaxf0   radial cutoff for contours at outer edge of efit domain
yminf0 (nsearch)
yminf0   vertical cutoff for contours at upper edge of efit domain
ymaxf0 (nsearch)
ymaxf0   vertical cutoff for contours at lower edge of efit domain
istcvon 
istcvon   obsolete option istcvon=1; use altsearch=2 instead.
altsearch 
altsearch   flag to change search path for private flux surfaces
altsearch   altsearch=0 --> search vertically up toward x-point
altsearch   altsearch=1 --> search vertically down from x-point
altsearch   altsearch=2 --> search diagonally down and in from x-point

                      Inpf
                      ------------------------

            local variables for flux contouring; see inpf0 description
                      ------------------------
ncmin 
ncmin   flux index of first poloidal flux curve
ncmax 
ncmax   flux index of last poloidal flux curve
iserch (jdim)
iserch   horizontal (x) index of starting point for flux contour search
iserch   on refined EFIT grid
jserch (jdim)
jserch   vertical (y) index of starting point for flux contour search
jserch   on refined EFIT grid
istepf 
istepf   horizontal step size (on refined EFIT mesh) for contour search path
jstepf 
jstepf   vertical step size (on refined EFIT mesh) for contour search path
leadir (jdim)
leadir   specifies initial direction for flux contour search, subsequent movement :
leadir   leadir = 1    upward vertical search - contouring right, then left
leadir   leadir = 2    rightward horizontal search - contouring down, then up
leadir   leadir = 3    upward vertical search - contouring left, then right
leadir   leadir = 4    rightward horizontal search - contouring up, then down
leadir   leadir = 5    downward vertical search - contouring left, then right
leadir   leadir = 6    downward vertical search - contouring right, then left
xlbnd 
xlbnd   radial cutoff for contours at inner edge of efit domain
xubnd 
xubnd   radial cutoff for contours at outer edge of efit domain
ylbnd 
ylbnd   vertical cutoff for contours at lower edge of efit domain
yubnd 
yubnd   vertical cutoff for contours at upper edge of efit domain
ncmin1 
ncmin1   flux index of first poloidal flux curve
ncmax1 
ncmax1   flux index of last poloidal flux curve

                      Polflx
                      ------------------------

            flux contouring variables on the refined grid
                      ------------------------
plflux (jdim)
plflux   temporary array of poloidal flux values in a search region
mrfac 
mrfac   mesh refinement factor relative to EFIT
nx4 
nx4   number of grid surfaces in x-direction on refined grid
ny4 
ny4   number of grid surfaces in y-direction on refined grid
x (nx4)
x   radial position of grid surfaces in x-direction on refined grid
y (ny4)
y   vertical position of grid surfaces in y-direction on refined grid
f (nx4,ny4)
f   poloidal magnetic flux values on refined grid
xcurve (npts,jdim)
xcurve   radial position of nth data point on jth contour segment
ycurve (npts,jdim)
ycurve   vertical position of nth data point on jth contour segment
npoint (jdim)
npoint   number of data points on jth contour segment
ijumpf (jdim)
ijumpf   core/p.f. discontinuity on flux contour j occurs between
ijumpf   data points ijumpf(j) and ijumpf(j)+1
dsjumpf 
dsjumpf   criterion for 'jump' discontinuity in core/p.f. contours
ilast (jdim)
ilast   comment needed
xcn (npts)
xcn   comment needed
ycn (npts)
ycn   comment needed
imin 
imin   comment needed
imax 
imax   comment needed
istart 
istart   comment needed
jmins 
jmins   comment needed
jmaxs 
jmaxs   comment needed
jstart 
jstart   comment needed
ncontr 
ncontr   comment needed
pfr 
pfr   comment needed
twopie 
twopie   comment needed
xminf 
xminf   comment needed
xmaxf 
xmaxf   comment needed
yminf 
yminf   comment needed
ymaxf 
ymaxf   comment needed
rs_com 
rs_com  rm output from subr. findstrike via common for python
zs_com 
zs_com  zm output from subr. findstrike via common for python 

                      Neqdskv
                      ------------------------

            information read from the G-file produced by the EFIT code
                      ------------------------
nxefit 
nxefit   number of grid surfaces in x (horizontal) direction
nyefit 
nyefit   number of grid surfaces in y (vertical) direction
xold (nxefit)
xold   horizontal position (major radius) of grid surfaces
yold (nyefit)
yold   vertical position of grid surfaces
fold (nxefit,nyefit)
fold   poloidal magnetic flux at EFIT grid points
bscoef (nxefit,nyefit)
bscoef   2-d spline coefficients 
kxord 
kxord   order of the spline in the x-direction
kyord 
kyord   order of the spline in the y-direction
xknot (nxefit+kxord)
xknot   knot sequence in the x-direction for 2-d spline subroutines
yknot (nyefit+kyord)
yknot   knot sequence in the y-direction for 2-d spline subroutines
ldff 
ldff   leading dimension of 2-d spline coefficient array
iflagf 
iflagf   input/output flag for 2-d spline subroutines
workf (nworkf)
workf   work array for 2-d spline subroutines
bcentr 
bcentr   reference toroidal field
rcentr 
rcentr   major radius of point where vacuum toroidal field is bcentr
rmagx 
rmagx   major radius of magnetic axis
zmagx 
zmagx   vertical position of magnetic axis
simagx 
simagx   poloidal magnetic flux at the magnetic axis
sibdry 
sibdry   poloidal magnetic flux at primary x-point
sibdry1 
sibdry1   poloidal magnetic flux at the lower x-point
sibdry2 
sibdry2   poloidal magnetic flux at the upper x-point
xdim 
xdim   horizontal (radial) extent of EFIT computational grid
zdim 
zdim   vertical extent of EFIT computational grid
zmid 
zmid   midplane position of EFIT computational grid
zshift 
zshift   vertical shift of EFIT data that makes z=0 at the bottom of the mesh
runid 
runid   output label from EFIT in neqdsk file
workk (nxefit)
workk   dummy array for neqdsk output
fpol (nxefit)
fpol   poloidal current F(psi) = R*B_toroidal from geqdsk
pres (nxefit)
pres   dummy array for neqdsk output
qpsi (nxefit)
qpsi   dummy array for neqdsk output
rgrid1 
rgrid1   major radius at inner edge of EFIT grid
cpasma 
cpasma   toroidal current in the core plasma
nbdry 
nbdry   number of data points on last closed flux surface
rbdry (nbdry)
rbdry   radial coordinates of data points on last closed flux surface
zbdry (nbdry)
zbdry   vertical coordinates of data points on last closed flux surface
nlim 
nlim   number of data points on limiter/vessel boundary
xlim (nlim)
xlim   radial coordinates of data points on limiter/vessel boundary
ylim (nlim)
ylim   vertical coordinates of data points on limiter/vessel boundary

                      Aeqdskv
                      ------------------------

            information read from the A-file produced by the EFIT code
                      ------------------------
vmonth 
vmonth   EFIT version month
vday 
vday   EFIT version day
vyear 
vyear   EFIT version year
eshot 
eshot   shot number from EFIT
etime 
etime   time slice from EFIT
rseps 
rseps   major radius of lower x-point
zseps 
zseps   vertical position of lower x-point
rseps1 
rseps1   major radius of lower x-point
zseps1 
zseps1   vertical position of lower x-point
rseps2 
rseps2   major radius of upper x-point
zseps2 
zseps2   vertical position of upper x-point
rvsin 
rvsin   major radius of inboard strike point
zvsin 
zvsin   vertical position of inboard strike point
rvsout 
rvsout   major radius of outboard strike point
zvsout 
zvsout   vertical position of outboard strike point
mco2v 
mco2v   number of vertical co2 chords
mco2r 
mco2r   number of radial co2 chords
rco2v (mco2v)
rco2v   radial positions of vertical co2 chords
dco2v (mco2v)
dco2v   densities for vertical co2 chords
rco2r (mco2r)
rco2r   vertical positions of radial co2 chords
dco2r (mco2r)
dco2r   densities for radial co2 chords
nsilop 
nsilop   number of flux loops
csilop (nsilop)
csilop   data from flux loops
magpri 
magpri   number of magnetic pickup loops
cmpr2 (magpri)
cmpr2   data from magnetic pickup loops
nfcoil 
nfcoil   number of f-coils
ccbrsp (nfcoil)
ccbrsp   data from f-coils
nesum 
nesum   number of e-coils
eccurt (nesum)
eccurt   data from e-coils

                      Rho
                      ------------------------

            various analytic forms for choosing rho versus t
                      ------------------------
rho1 (t,rho,nt,t1,t2,t3,r1,r2,r3,alf)
rho1   Defines rho(t) as a rational function of the form (f+gt)/(p+qt) on
rho1   the interval t1 < t < t2 (the plasma core region) and
rho1   an exponential function of the form sinh(at+b) on
rho1   the interval t2 < t < t3 (the scrape-off layer region) with
rho1   continuous first derivative at t2.
rho1   input array is t(0:nt) and output array is rho(0:nt).
rho1   alf sets the strength of the exponential behavior which
rho1   becomes linear in the limit alf ---> 0.
rho1dn (t,rho,nt,t1,t2,t3,t4,r1,r2,r3,r4,alf)
rho1dn   Defines rho(t) for unbalanced double-null configurations:
rho1dn   rho(t) is a rational function of the form (f+gt)/(p+qt) on
rho1dn   the interval t1 < t < t2 (the inner core region) and also on the
rho1dn   interval t2 < t < t3 (between separatrices), and has an exponential
rho1dn   form sinh(at+b) on the interval t3 < t < t4 (the scrape-off layer
rho1dn   region) with continuous first derivatives at t2 and t3.
rho1dn   t(0:nt) is an input array and rho(0:nt) is the output array.
rho1dn   alf sets the strength of the exponential behavior which
rho1dn   becomes linear in the limit alf ---> 0.
rho2dn (t,rho,nt,t1,t2,t3,t4,r1,r2,r3,r4,fac)
rho2dn   Defines rho(t) for unbalanced double-null configurations:
rho2dn   rho(t) is a piece-wise rational function of the form (f+gt)/(p+qt)
rho2dn   on the intervals t1 < t < t2 (the inner core region), t2 < t < t3
rho2dn   (between separatrices), and  t3 < t < t4 (the outer scrape-off layer
rho2dn   region) with continuous first derivatives at t2 and t3.
rho2dn   t(0:nt) is an input array and rho(0:nt) is the output array.
rho2dn   fac is a scaling factor for the slopes at t2 and t3:
rho2dn        rho'(t2)=((r3-r2)/(t3-t2))*fac
rho2dn        rho'(t3)=((r3-r2)/(t3-t2))/fac
rho3dn (t,rho,nt,t1,t2,t3,t4,r1,r2,r3,r4,slp2fac,slp3fac,r2p,r3p)
rho3dn   Defines rho(t) for unbalanced double-null configurations:
rho3dn   rho(t) is a cubic function on the interval t2 < t < t3 (between
rho3dn   separatrices) and a piece-wise rational function of the form
rho3dn   (f+gt)/(p+qt) on the intervals t1 < t < t2 (the inner core region)
rho3dn   and  t3 < t < t4 (the outer scrape-off layer region) with
rho3dn   continuous first derivatives at t2 and t3.
rho3dn   t(0:nt) is an input array and rho(0:nt) is the output array.
rho3dn   slp2fac & slp3fac are scaling factors for the slopes at t2 and t3:
rho3dn        rho'(t2)=((r3-r2)/(t3-t2))*slp2fac
rho3dn        rho'(t3)=((r3-r2)/(t3-t2))*slp3fac
rho1l (t,rho,nt,t1,t2,r1,r2,r1p)
rho1l   rho(t) is a rational function of the form
rho1l   (f+gt)/(p+qt) on the interval t1 < t < t2
rho1l   with specified derivative at the left boundary.
rho1r (t,rho,nt,t1,t2,r1,r2,r2p)
rho1r   rho(t) is a rational function of the form
rho1r   (f+gt)/(p+qt) on the interval t1 < t < t2
rho1r   with specified derivative at the right boundary.
rho2 (t,rho,nt,t1,t2,t3,r1,r2,r3)
rho2   Defines rho(t) as quadratic on the interval t1 < t < t2
rho2   and linear on the interval t2 < t < t3 with continuous
rho2   first derivative at t2.
rho2   nt specifies the length of input array t and output array rho.
rho3 (t,rho,nt,t1,t2,t3,r1,r2,r3)
rho3   Defines rho(t) as cubic on the interval t1 < t < t2
rho3   and linear on the interval t2 < t < t3 with continuous
rho3   first and second derivatives at t2.
rho3   nt specifies the length of input array t and output array rho.
rho4 (t,rho,nt,t1,t2,t3,r1,r2,r3,s2)
rho4   Defines rho(t) as a cubic on the interval t1 < t < t3 
rho4   with slope at t2 modified relative to quadratic 
rho5 (t,rho,nt,t1,t2,t3,r1,r2,r3,r2p)
rho5   Defines rho(t) as a piece-wise rational function of the form
rho5   (f+gt)/(p+qt) on each of the intervals t1 < t < t2 (core region)
rho5   and t2 < t < t3 (SOL region) with specified derivative rho'(t2).

                      Efit
                      ------------------------

            subroutines that the user can call directly
                      ------------------------
aeqdsk ()
aeqdsk   This subroutine reads Efit data from file aeqdsk.
neqdsk ()
neqdsk   This subroutine reads Efit data from file neqdsk.
readefit ()
readefit   This subroutine calls neqdsk and aeqdsk and procefit.
procefit ()
procefit   This subroutine assumes the equivalent of neqdsk and aeqdsk have
procefit   already been called. It then defines the vertical 
procefit   coordinate with the z=0 surface located at the bottom of the mesh
procefit   rather than at the midplane. 
contours (ns:integer)
contours   This subroutine computes the data for flux contours in search region ns
flxrun ()
flxrun   This is the main driver routine for the flx package.
inflx ()
inflx   This routine selects the psi values for the flux surfaces
theta_ok (r:real,z:real,n:integer)
theta_ok   test for theta [polar angle about (rmagx,zmagx)] within acceptable range
theta_ok   in contouring region n where:
theta_ok   n=1 inboard SOL and core
theta_ok   n=2 inboard private flux
theta_ok   n=3 outboard SOL and core
theta_ok   n=4 outboard private flux
efitvers (vmonth:integer,vday:integer,vyear:integer)
efitvers   test for updated version of EFIT (on or after 24 May 1997)
efitvers   =1 means new version
efitvers   =0 means old version
findstrike (js:integer,rs:real,zs:real)
findstrike   Finds the first intersection of a poloidal flux surface with
findstrike   the limiter surface from EFIT; input is flux surface index js;
findstrike   outputs are (rs,zs); assumes x,ycurve and x,ylim data exist.
